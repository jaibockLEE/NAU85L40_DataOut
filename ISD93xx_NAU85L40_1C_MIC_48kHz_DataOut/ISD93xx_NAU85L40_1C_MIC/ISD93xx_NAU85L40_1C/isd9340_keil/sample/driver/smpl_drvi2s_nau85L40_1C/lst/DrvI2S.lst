L 1 "..\..\..\Src\Driver\DrvI2S.c"
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) 2011 Nuvoton Technology Corp. All rights reserved.                                         */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060009
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 7 "..\..\..\Src\Driver\DrvI2S.c" 2
N#include "DrvI2S.h"
L 1 "..\..\..\Include\Driver\DrvI2S.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) 2011 Nuvoton Technology Corp. All rights reserved.                                         */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef _DRVI2S_H
N#define _DRVI2S_H
N
N#include "isd93xx.h"
L 1 "..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\ISD93xx\isd93xx.h" 1
N/*----------------------------------------------------------------------------------------------*/
N/*                                                                                              */
N/* Copyright (c) Nuvoton Technology Corp. All rights reserved.                                  */
N/*                                                                                              */
N/*----------------------------------------------------------------------------------------------*/
N/*
N * @file     ISD0xx.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N *           for ISD91XX CM0 Device Series
N * @date     5. April 2011
N *
N ------------------------------------------------------------------------------------------------*/
N#ifndef __ISD9xx_H__
N#define __ISD9xx_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N#if 0
S} /* Fool Emacs into not indenting things. */
N#endif
N/** @addtogroup ISD91XX_Definitions ISD91XX Definitions
N    This file defines all structures and symbols for ISD91XX:
N    - registers and bitfields
N    - peripheral base address
N    - peripheral ID
N    - Peripheral definitions
N    @{
N*/
N/******************************************************************************/
N/*                Processor and Core Peripherals                              */
N/******************************************************************************/
N/** @addtogroup ISD91XX_CMSIS Device CMSIS Definitions
N    Configuration of the Cortex-M# Processor and Core Peripherals
N    @{
N*/
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
Ntypedef enum IRQn
N    {
N        /******  Cortex-M0 Processor Exceptions Numbers *************************************************/
N        NonMaskableInt_IRQn       = -14,    /*!< 2 Non Maskable Interrupt                               */
N        HardFault_IRQn		      = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                   */
N        SVCall_IRQn               = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                         */
N        PendSV_IRQn               = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                         */
N        SysTick_IRQn              = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                     */
N        /******  ARMIKMCU Swift specific Interrupt Numbers **********************************************/
N        BOD_IRQn                  = 0,        /*!< 16 Brown Out Detector Device Interrupt               */
N        WDT_IRQn                  = 1,        /*!< 17 Watchdog Timer Device Interrupt                   */
N        EINT0_IRQn                = 2,        /*!< 18 External Interrupt PB0 Interrupt                  */
N        EINT1_IRQn                = 3,        /*!< 19 External Interrupt PB1 Interrupt                  */
N        GPAB_IRQn                 = 4,        /*!< 20 GPIO Interrupt                                    */
N        ALC_IRQn                  = 5,        /*!< 21 ALC Interrupt                                     */
N        PWMA_IRQn                 = 6,        /*!< 22 PWM A Peripheral Device Interrupt                 */
N        PWMB_IRQn                 = 8,        /*!< 23 PWM B Peripheral Device Interrupt                 */
N        TMR0_IRQn                 = 8,        /*!< 24 Timer 0 Interrupt                                 */
N        TMR1_IRQn                 = 9,        /*!< 25 Timer 1 Interrupt                                 */
N        IRQ10n                    = 10,
N        IRQ11n                    = 11,
N        UART0_IRQn                = 12,        /*!< 28 UART Device Interrupt                            */
N        IRQ13n                    = 13,
N        SPI0_IRQn                 = 14,        /*!< 30 SPI Interface Interrupt                          */
N        IRQ15n                    = 15,
N        IRQ16n                    = 16,
N        IRQ17n                    = 17,
N        I2C0_IRQn                 = 18,        /*!< 34 I2C Interface Interrupt                          */
N        IRQ19n                    = 19,
N        IRQ20n                    = 20,
N        TALARM_IRQn               = 21,        /*!< 37 Temperature Alaram Interrupt                     */
N        IRQ22n                    = 22,
N        IRQ23n                    = 23,
N        IRQ24n                    = 24,
N        ACMP_IRQn                 = 25,        /*!< 41 Analog Comparator Interrupt                      */
N        PDMA_IRQn                 = 26,        /*!< 42 Peripheral DMA Interrupt                         */
N        I2S_IRQn                  = 27,        /*!< 43 I2S Interface Device Interrupt                   */
N        CAPS_IRQn                 = 28,        /*!< 44 CapSense Device Interrupt                        */
N        ADC_IRQn                  = 29,        /*!< 45 Audio ADC Device Interrupt                       */
N        IRQ30n                    = 30,
N        RTC_IRQn                  = 31         /*!< 47 Real Time Clock Interrupt                        */
N
N        /*!< maximum of 32 Interrupts are possible                */
N    } IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
N#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
N#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
N/*@}*/ /* end of group ISD91XX_CMSIS */
N
N#include "core_cm0.h"                   /* Cortex-M0 processor and core peripherals               */
L 1 "..\..\..\..\CMSIS\CM0\CoreSupport\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V2.01
N * @date     06. December 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )                   
X#if 0L                   
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N
N/** \mainpage CMSIS Cortex-M0
N   
N  This documentation describes the CMSIS Cortex-M Core Peripheral Access Layer.
N  It consists of:
N 
N     - Cortex-M Core Register Definitions
N     - Cortex-M functions
N     - Cortex-M instructions
N 
N  The CMSIS Cortex-M0 Core Peripheral Access Layer contains C and assembly functions that ease 
N  access to the Cortex-M Core
N */ 
N
N/** \defgroup CMSIS_LintCinfiguration CMSIS Lint Configuration
N  List of Lint messages which will be suppressed and not shown:
N    - not yet checked
N  .
N  Note:  To re-enable a Message, insert a space before 'lint' *
N 
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \defgroup CMSIS_core_definitions CMSIS Core Definitions
N  This file defines all structures and symbols for CMSIS core:
N   - CMSIS version number
N   - Cortex-M core 
N   - Cortex-M core Revision Number
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x02)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (0x00)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | __CM0_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x00)                                                       /*!< Cortex core                    */
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S
N#endif
N
N#include <stdint.h>                      /*!< standard types definitions                      */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060009
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 95 "..\..\..\..\CMSIS\CM0\CoreSupport\core_cm0.h" 2
N#include "core_cmInstr.h"                /*!< Core Instruction Access                         */
L 1 "..\..\..\..\CMSIS\CM0\CoreSupport\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V2.01
N * @date     06. December 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H__
N#define __CORE_CMINSTR_H__
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if defined ( __CC_ARM   ) /*------------------ RealView Compiler ----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor, 
N    so that all instructions following the ISB are fetched from cache or 
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier. 
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before 
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#if (__ARMCC_VERSION < 400677)
X#if (5060183 < 400677)
Sextern uint32_t __REV16(uint32_t value);
N#else  /* (__ARMCC_VERSION >= 400677)  */
Nstatic __INLINE __ASM uint32_t __REV16(uint32_t value)
Xstatic __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif /* __ARMCC_VERSION  */ 
N
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#if (__ARMCC_VERSION < 400677)
X#if (5060183 < 400677)
Sextern int32_t __REVSH(int32_t value);
N#else  /* (__ARMCC_VERSION >= 400677)  */
Nstatic __INLINE __ASM int32_t __REVSH(int32_t value)
Xstatic __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif /* __ARMCC_VERSION  */ 
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#if (__ARMCC_VERSION < 400000)
Sextern void __CLREX(void);
S#else  /* (__ARMCC_VERSION >= 400000)  */
S#define __CLREX                           __clrex
S#endif /* __ARMCC_VERSION  */ 
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz 
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif (defined (__ICCARM__)) /*---------------- ICC Compiler ---------------------*/
S/* IAR iccarm specific functions */
S
S#include <intrinsics.h>                     /* IAR Intrinsics   */
S
S#pragma diag_suppress=Pe940
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S#define __NOP                           __no_operation
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
Sstatic __INLINE  void __WFI(void)
S{
S  __ASM ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
Sstatic __INLINE  void __WFE(void)
S{
S  __ASM ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
Sstatic __INLINE  void __SEV(void)
S{
S  __ASM ("sev");
S}
S
S
S/* intrinsic     void __ISB(void)            (see intrinsics.h) */
S/* intrinsic     void __DSB(void)            (see intrinsics.h) */
S/* intrinsic     void __DMB(void)            (see intrinsics.h) */
S/* intrinsic uint32_t __REV(uint32_t value)  (see intrinsics.h) */
S/* intrinsic          __SSAT                 (see intrinsics.h) */
S/* intrinsic          __USAT                 (see intrinsics.h) */
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
Sstatic uint32_t __REV16(uint32_t value)
S{
S  __ASM("rev16 r0, r0");
S}
S
S
S/* intrinsic uint32_t __REVSH(uint32_t value)  (see intrinsics.h */
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
Sstatic uint32_t __RBIT(uint32_t value)
S{
S  __ASM("rbit r0, r0");
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
Sstatic uint8_t __LDREXB(volatile uint8_t *addr)
S{
S  __ASM("ldrexb r0, [r0]");
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
Sstatic uint16_t __LDREXH(volatile uint16_t *addr)
S{
S  __ASM("ldrexh r0, [r0]");
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S/* intrinsic unsigned long __LDREX(unsigned long *)  (see intrinsics.h) */
Sstatic uint32_t __LDREXW(volatile uint32_t *addr)
S{
S  __ASM("ldrex r0, [r0]");
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
Sstatic uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S  __ASM("strexb r0, r0, [r1]");
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
Sstatic uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S  __ASM("strexh r0, r0, [r1]");
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long)  (see intrinsics.h )*/
Sstatic uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S  __ASM("strex r0, r0, [r1]");
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
Sstatic __INLINE void __CLREX(void)
S{
S  __ASM ("clrex");
S}
S
S/* intrinsic   unsigned char __CLZ( unsigned long )      (see intrinsics.h) */
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S#pragma diag_default=Pe940
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor, 
S    so that all instructions following the ISB are fetched from cache or 
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier. 
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before 
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S  
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S  
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S  
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S  
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S  
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S  
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S  
S   __ASM volatile ("strexb %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S  
S   __ASM volatile ("strexh %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S  
S   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) static __INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S  
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif (defined (__TASKING__)) /*--------------- TASKING Compiler -----------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H__ */
L 96 "..\..\..\..\CMSIS\CM0\CoreSupport\core_cm0.h" 2
N#include "core_cmFunc.h"                 /*!< Core Function Access                            */
L 1 "..\..\..\..\CMSIS\CM0\CoreSupport\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V2.01
N * @date     06. December 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H__
N#define __CORE_CMFUNC_H__
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface   
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if defined ( __CC_ARM   ) /*------------------ RealView Compiler ----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060183 <  400000)
Sextern          uint32_t __get_CONTROL(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060183 <  400000)
Sextern          void __set_CONTROL(uint32_t control);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get ISPR Register
N
N    This function returns the content of the ISPR Register.
N
N    \return               ISPR Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060183 <  400000)
Sextern          uint32_t __get_IPSR(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060183 <  400000)
Sextern          uint32_t __get_APSR(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060183 <  400000)
Sextern          uint32_t __get_xPSR(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060183 <  400000)
Sextern          uint32_t __get_PSP(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060183 <  400000)
Sextern          void __set_PSP(uint32_t topOfProcStack);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060183 <  400000)
Sextern          uint32_t __get_MSP(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060183 <  400000)
Sextern          void __set_MSP(uint32_t topOfMainStack);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060183 <  400000)
Sextern          uint32_t __get_PRIMASK(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060183 <  400000)
Sextern          void __set_PRIMASK(uint32_t priMask);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N#endif /*  __ARMCC_VERSION  */ 
N 
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S#if       (__ARMCC_VERSION <  400000)
Sextern          uint32_t __get_BASEPRI(void);
S#else  /* (__ARMCC_VERSION >= 400000) */
Sstatic __INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S#endif /*  __ARMCC_VERSION  */ 
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S#if       (__ARMCC_VERSION <  400000)
Sextern          void __set_BASEPRI(uint32_t basePri);
S#else  /* (__ARMCC_VERSION >= 400000) */
Sstatic __INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S#endif /*  __ARMCC_VERSION  */ 
S 
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S#if       (__ARMCC_VERSION <  400000)
Sextern          uint32_t __get_FAULTMASK(void);
S#else  /* (__ARMCC_VERSION >= 400000) */
Sstatic __INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S#endif /*  __ARMCC_VERSION  */ 
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S#if       (__ARMCC_VERSION <  400000)
Sextern          void __set_FAULTMASK(uint32_t faultMask);
S#else  /* (__ARMCC_VERSION >= 400000) */
Sstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & 1);
S}
S#endif /*  __ARMCC_VERSION  */ 
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
Sstatic __INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
Sstatic __INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N #elif (defined (__ICCARM__)) /*---------------- ICC Compiler ---------------------*/
S/* IAR iccarm specific functions */
S
S#if defined (__ICCARM__)
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
S#endif
S
S#pragma diag_suppress=Pe940
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S#define __enable_irq                              __enable_interrupt
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S#define __disable_irq                             __disable_interrupt
S
S
S/* intrinsic unsigned long __get_CONTROL( void ); (see intrinsic.h) */
S/* intrinsic void __set_CONTROL( unsigned long ); (see intrinsic.h) */
S
S
S/** \brief  Get ISPR Register
S
S    This function returns the content of the ISPR Register.
S
S    \return               ISPR Register value
S */
Sstatic uint32_t __get_IPSR(void)
S{
S  __ASM("mrs r0, ipsr");
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
Sstatic uint32_t __get_APSR(void)
S{
S  __ASM("mrs r0, apsr");
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
Sstatic uint32_t __get_xPSR(void)
S{
S  __ASM("mrs r0, psr");           // assembler does not know "xpsr"
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
Sstatic uint32_t __get_PSP(void)
S{
S  __ASM("mrs r0, psp");
S}
S 
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
Sstatic void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM("msr psp, r0");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
Sstatic uint32_t __get_MSP(void)
S{
S  __ASM("mrs r0, msp");
S}
S 
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
Sstatic void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM("msr msp, r0");
S}
S 
S
S/* intrinsic unsigned long __get_PRIMASK( void ); (see intrinsic.h) */
S/* intrinsic void __set_PRIMASK( unsigned long ); (see intrinsic.h) */
S 
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
Sstatic __INLINE void __enable_fault_irq(void)
S{
S  __ASM ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
Sstatic __INLINE void __disable_fault_irq(void)
S{
S  __ASM ("cpsid f");
S}
S
S
S/* intrinsic unsigned long __get_BASEPRI( void );   (see intrinsic.h) */
S/* intrinsic void __set_BASEPRI( unsigned long );   (see intrinsic.h) */
S/* intrinsic unsigned long __get_FAULTMASK( void ); (see intrinsic.h) */
S/* intrinsic void __set_FAULTMASK(unsigned long);   (see intrinsic.h) */
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
Sstatic uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1)
S  __ASM("vmrs r0, fpscr"); 
S#else
S  return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
Sstatic void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1)
S  __ASM("vmsr fpscr, r0");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S#pragma diag_default=Pe940
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get ISPR Register
S
S    This function returns the content of the ISPR Register.
S
S    \return               ISPR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S 
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S 
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S 
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S  
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S  
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1)
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1)
S  __ASM volatile ("MSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif (defined (__TASKING__)) /*--------------- TASKING Compiler -----------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H__ */
L 97 "..\..\..\..\CMSIS\CM0\CoreSupport\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* IO definitions (access restrictions to peripheral registers) */
N#ifdef __cplusplus
S  #define     __I     volatile           /*!< defines 'read only' permissions                 */
N#else
N  #define     __I     volatile const     /*!< defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< defines 'write only' permissions                */
N#define     __IO    volatile             /*!< defines 'read / write' permissions              */
N
N/*@} end of group CMSIS_core_definitions */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N/** \defgroup CMSIS_core_register CMSIS Core Register
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N*/
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_CORE CMSIS Core
N  Type definitions for the Cortex-M Core Registers
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */ 
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_NVIC CMSIS NVIC
N  Type definitions for the Cortex-M NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IPR[8];                  /*!< Offset: 0x3EC (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IPR[8];                   
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_SCB CMSIS SCB
N  Type definitions for the Cortex-M System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPU ID Base Register                                  */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control State Register                      */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;                                      
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt / Reset Control Register        */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;                                      
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N       uint32_t RESERVED2[2];                                   
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N} SCB_Type;                                                
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_SysTick CMSIS SysTick
N  Type definitions for the Cortex-M System Timer Registers
N  @{
N */
N
N/* SysTick constants - copied from \Keil\ARM\RV31\INC\core_cm0.h */
N#define SYSTICK_ENABLE              0                                          /* Config-Bit to start or stop the SysTick Timer                         */
N#define SYSTICK_TICKINT             1                                          /* Config-Bit to enable or disable the SysTick interrupt                 */
N#define SYSTICK_CLKSOURCE           2                                          /* Clocksource has the offset 2 in SysTick Control and Status Register   */
N#define SYSTICK_MAXCOUNT       ((1<<24) -1)                                    /* SysTick MaxCount                                                      */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_CoreDebug CMSIS Core Debug
N  Type definitions for the Cortex-M Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_DWTENA_Pos         24                                             /*!< CoreDebug DEMCR: DWTENA Position */
N#define CoreDebug_DEMCR_DWTENA_Msk         (1UL << CoreDebug_DEMCR_DWTENA_Pos)            /*!< CoreDebug DEMCR: DWTENA Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup  CMSIS_core_register   
N  @{
N */
N 
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address           */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface CMSIS Core Function Interface
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface   
N    \defgroup CMSIS_Core_NVICFunctions CMSIS Core NVIC Functions
N  @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    This function enables a device specific interupt in the NVIC interrupt controller.
N    The interrupt number cannot be a negative value. 
N
N    \param [in]      IRQn  Number of the external interrupt to enable
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    This function disables a device specific interupt in the NVIC interrupt controller.
N    The interrupt number cannot be a negative value. 
N
N    \param [in]      IRQn  Number of the external interrupt to disable
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    This function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt. 
N
N    \param [in]      IRQn  Number of the interrupt for get pending
N    \return             0  Interrupt status is not pending
N    \return             1  Interrupt status is pending
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    This function sets the pending bit for the specified interrupt. 
N    The interrupt number cannot be a negative value.
N
N    \param [in]      IRQn  Number of the interrupt for set pending
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    This function clears the pending bit for the specified interrupt. 
N    The interrupt number cannot be a negative value.
N
N    \param [in]      IRQn  Number of the interrupt for clear pending
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    This function sets the priority for the specified interrupt. The interrupt 
N    number can be positive to specify an external (device specific) 
N    interrupt, or negative to specify an internal (core) interrupt.
N
N    Note: The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Number of the interrupt for set priority
N    \param [in]  priority  Priority to set
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) | 
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) | 
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IPR[_IP_IDX(IRQn)] = (NVIC->IPR[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->IPR[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->IPR[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    This function reads the priority for the specified interrupt. The interrupt 
N    number can be positive to specify an external (device specific) 
N    interrupt, or negative to specify an internal (core) interrupt.
N
N    The returned priority value is automatically aligned to the implemented
N    priority bits of the microcontroller.
N
N    \param [in]   IRQn  Number of the interrupt for get priority
N    \return             Interrupt Priority
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)((NVIC->IPR[_IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->IPR[( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    This function initiate a system reset request to reset the MCU.
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */              
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      | 
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL))->AIRCR  = ((0x5FA << 16)      | 
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */              
X  __dsb(0xF);                                                                    
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface   
N    \defgroup CMSIS_Core_SysTickFunctions CMSIS Core SysTick Functions
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    This function initialises the system tick timer and its interrupt and start the system tick timer.
N    Counter is in free running mode to generate periodical interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{ 
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFUL << 0))  return (1);             
N                                                               
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL))->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL))->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL))->CTRL  = (1UL << 2) | 
N                   SysTick_CTRL_TICKINT_Msk   | 
X                   (1UL << 1)   | 
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
N
N/*lint -restore */
L 102 "..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\ISD93xx\isd93xx.h" 2
N#include "system_ISD93xx.h"              /* ISD9xx System include file                             */
L 1 "..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\ISD93xx\system_ISD93xx.h" 1
N/**************************************************************************//**
N * @file     system_ARMCM0.h
N * @brief    CMSIS Cortex-M0 Device System Header File
N *           for CM0 Device Series
N * @version  V1.03
N * @date     24. September 2010
N *
N * @note
N * Copyright (C) 2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __SYSTEM_ARMCM0_H
N#define __SYSTEM_ARMCM0_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/* SysTick constants */
N#define SYSTICK_ENABLE              0                                          /* Config-Bit to start or stop the SysTick Timer                         */
N#define SYSTICK_TICKINT             1                                          /* Config-Bit to enable or disable the SysTick interrupt                 */
N#define SYSTICK_CLKSOURCE           2                                          /* Clocksource has the offset 2 in SysTick Control and Status Register   */
N#define SYSTICK_MAXCOUNT       ((1<<24) -1)                                    /* SysTick MaxCount    */  
N
N
Nextern uint32_t SystemCoreClock;     /*!< System Clock Frequency (Core Clock)  */
N
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock 
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SYSTEM_ARMCM0_H */
L 103 "..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\ISD93xx\isd93xx.h" 2
N#include "System\SysInfra.h"
L 1 "..\..\..\Include\System\SysInfra.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright (c) Nuvoton Technology Corp. All rights reserved.                                             */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N
N
N#ifndef __SYSINFRA_H__
N#define __SYSINFRA_H__
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Includes of system headers                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "ModuleID.h"
L 1 "..\..\..\Include\System\ModuleID.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright (c) Nuvoton Technology Corp. All rights reserved.                                             */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#ifndef __MODULE_ID_H__
N#define __MODULE_ID_H__
N
N
Ntypedef enum
N{
N	/* Module ID valid range: 0 ~ 255 */
N	
N	/* Driver: Module ID					Module Name */
N	MODULE_ID_DRVPROTECT		= 0,		/* DrvProtect */
N
N	MODULE_ID_DRVADC			= 2,		/* DrvADC  */
N	MODULE_ID_DRVAIC			= 4,		/* DrvAIC  */
N	MODULE_ID_DRVAPU			= 6,		/* DrvAPU  */
N	MODULE_ID_DRVAUDIOADC		= 8,		/* DrvAudioADC */
N	MODULE_ID_DRVACMP   		= 9,		/* DrvACMP */
N	MODULE_ID_DRVCACHE			= 10,		/* DrvCache	*/
N	MODULE_ID_DRVCAN			= 11,		/* DrvCAN */
N	MODULE_ID_DRVEBI			= 12,		/* DrvEBI */
N	MODULE_ID_DRVEDMA			= 13,		/* DrvEDMA */
N	MODULE_ID_DRVGDMA			= 14,		/* DrvGDMA */
N	MODULE_ID_DRVFSC			= 15,		/* DrvFSC */
N	MODULE_ID_DRVGE				= 16,		/* DrvGE  */
N	MODULE_ID_DRVFMC			= 17,		/* DrvFMC */
N	MODULE_ID_DRVGPIO			= 18,		/* DrvGPIO */
N	MODULE_ID_DRVOSC			= 19,		/* DrvOSC */
N	
N	MODULE_ID_DRVGPU			= 20,		/* DrvGPU */
N	MODULE_ID_DRVI2C			= 22,		/* DrvI2C (S/W I2C for Non-UL; H/W I2C for UL) */
N	MODULE_ID_DRVI2S			= 24,		/* DrvI2S */
N	MODULE_ID_DRVI2SM			= 26,		/* DrvI2SM	*/
N	MODULE_ID_DRVMPU			= 28,		/* DrvMPU */
N	MODULE_ID_DRVNAND			= 30,		/* DrvNAND */
N	MODULE_ID_DRVNOR			= 32,		/* DrvNOR */
N	MODULE_ID_DRVPDMA     		= 33,       /* DrvPDMA */
N	MODULE_ID_DRVPWM			= 34,		/* DrvPWM */
N	MODULE_ID_DRVPS2			= 35,		/* DrvPS2 */
N	MODULE_ID_DRVRTC			= 36,		/* DrvRTC */
N	MODULE_ID_DRVSDCARD			= 38,		/* DrvSDCard */
N	MODULE_ID_DRVSIO			= 39,		/* DrvSerialIO */
N
N	MODULE_ID_DRVSPI			= 40,		/* DrvSPI */
N	MODULE_ID_DRVSPIMS			= 41,		/* DrvSPIMS	*/
N	MODULE_ID_DRVSPIFLASH		= 42,		/* DrvSPIFlash */
N	MODULE_ID_DRVSPIM			= 43,		/* DrvSPIM */
N	MODULE_ID_DRVSYS			= 44,		/* DrvSystem */
N	MODULE_ID_DRVSPU			= 45,		/* DrvSPU */
N	MODULE_ID_DRVTIMER			= 46,		/* DrvTimer	*/
N	MODULE_ID_DRVUART			= 48,		/* DrvUART */
N	MODULE_ID_DRVUSB			= 50,		/* DrvUSB */
N	MODULE_ID_DRVUSBH			= 52,		/* DrvUSBH */
N	MODULE_ID_DRVVDMA			= 54,		/* DrvVDMA */
N	MODULE_ID_DRVVIDEOIN		= 56,		/* DrvVideoIn */
N	MODULE_ID_DRVVPOST			= 58,		/* DrvVPOST	*/
N
N	MODULE_ID_DRVVRAM			= 60,		/* DrvVRAM	*/
N	MODULE_ID_DRVW55U02			= 62,		/* DrvW55U02 */
N	MODULE_ID_DRVI2CH			= 64,		/* DrvI2CH (H/W I2C for Non-UL) */
N	MODULE_ID_DRVWDT			= 66,		/* DrvWDT  */
N	MODULE_ID_DRVJPEG			= 68,		/* DrvJPEG */
N	
N	MODULE_ID_DRVZEROG			= 70,		/* DrvZeroG	 */
N	MODULE_ID_DRVSI2C			= 71,		/* DrvSI2C (S/W I2C for Non-UL) */
N
N	/* Audio: Module ID						Module Name */
N	MODULE_ID_AEC				= 81,		/* AEC	*/
N	MODULE_ID_BEATDET			= 82,		/* BeatDetection */
N	MODULE_ID_SNDEFF			= 83,		/* SoundEffect	*/
N	MODULE_ID_AUDIOSYN			= 84,		/* AudioSynthesizer */
N	MODULE_ID_G726ADPCM			= 85,		/* G726ADPCM  */
N	MODULE_ID_IMAADPCM			= 86,		/* IMAAdpcmCodec */
N	MODULE_ID_MP3DEC			= 88,		/* MP3Decoder */
N	MODULE_ID_PITCHCHANGE		= 90,		/* PitchChanger	*/
N	MODULE_ID_WAVFILEUTIL		= 92,		/* WavFileUtil */
N	MODULE_ID_WMADEC			= 96,		/* WMADecoder  */
N	MODULE_ID_WMADECDRM			= 98,		/* WMADecoderWithDrm */
N	MODULE_ID_AUDIOCTRL			= 100,		/* AudioCtrl */
N	MODULE_ID_EQ				= 106,		/* Equalizer */
N	MODULE_ID_OGGDEC			= 110,		/* OggDecoder */
N	MODULE_ID_MP3ENC			= 112,		/* MP3Encoder */
N	MODULE_ID_UADEC				= 114,		/* UltraAudioDec */
N	MODULE_ID_ULSPEECHDEC		= 115,		/* UltraLowSpeechDec */
N	MODULE_ID_USPEECHDEC		= 116,		/* UltraSpeechDec */
N	MODULE_ID_SPEECHRECOG		= 118,		/* SpeechRecog */
N
N	/* File System: Module ID				Module Name */
N	MODULE_ID_FS				= 120,		/* FileSystem */
N	
N	/* Flash Lite: Module ID				Module Name */
N	MODULE_ID_FL				= 128,		/* FlashLite */
N	
N	/* Communication: Module ID				Module Name */
N	MODULE_ID_KEYPAD			= 130,		/* Keypad  */
N	MODULE_ID_LWIP				= 132,		/* LwIP	  */
N	MODULE_ID_WLANMGR			= 134,		/* WLanMgr	*/
N	MODULE_ID_HTTPD				= 136,		/* HTTPD   */
N	MODULE_ID_VIRTUALCOM		= 139,		/* VirtualCOM */
N
N	/* Graphics: Module ID					Module Name */
N	MODULE_ID_GFXRESLDR			= 140,		/* GraphicsResLoader */
N	MODULE_ID_GFXLIB			= 141,		/* GraphicsLib */
N	MODULE_ID_IMGPROC			= 142,		/* ImageProcess	*/
N	MODULE_ID_JPEG				= 144,		/* JPEGCodec */
N	MODULE_ID_PNGDEC			= 146,		/* PNGCodec	*/
N	MODULE_ID_BARCODE2D			= 148,		/* BarCode2D */	 
N	MODULE_ID_PTNRECOG			= 150,		/* PtnRecog	*/
N	MODULE_ID_MOTIONDET			= 152,		/* MotionDection */
N	
N	/* Storage: Module ID					Module Name	*/
N	MODULE_ID_STORIF			= 160,		/* StorageInterface */
N	MODULE_ID_SDCARD			= 161,		/* SDCard */
N	MODULE_ID_SYSNAND			= 162,		/* SysNand */
N	MODULE_ID_SPIFLASH			= 163,		/* SPIFlash	*/
N	MODULE_ID_WTRIF				= 164,		/* WriterInterface */
N	MODULE_ID_NORFLASH			= 165,		/* NORFlash	*/
N	MODULE_ID_SYSNANDLITE		= 166,		/* SysNandLite */
N	
N	/* System: Module ID					Module Name */
N	MODULE_ID_INTMGR			= 180,		/* InterruptManager */
N	MODULE_ID_BLKLDR			= 181,		/* BlockLoader */
N	MODULE_ID_MEMMGR			= 182,		/* MemoryManager */
N	MODULE_ID_EVTMGR			= 183,		/* EventManager	*/
N	MODULE_ID_PROF				= 184,		/* Profiling  */
N	MODULE_ID_PROGLDR			= 186,		/* ProgramLoader */
N	MODULE_ID_SYSINFRA			= 188,		/* SysInfra	*/
N	MODULE_ID_TIMERCTRL			= 190,		/* TimerCtrl */
N	MODULE_ID_TIMEUTIL			= 192,		/* TimeUtil	*/
N	MODULE_ID_CONPROGLDR		= 194,		/* ConsoleProgramLoader */
N	
N	/* USB: Module ID						Module Name */
N	MODULE_ID_USBCOREH			= 78,		/* USBCoreH	*/
N	MODULE_ID_HID				= 220,		/* HID */
N	MODULE_ID_MASSSTOR			= 222,		/* MassStor */
N	MODULE_ID_MASSSTORHID		= 224,		/* MassStorHID */
N	MODULE_ID_MASSSTORLITE		= 226,		/* MassStorLite	*/
N	MODULE_ID_MTP				= 230,		/* MTP */
N	MODULE_ID_USBINFRA			= 232,		/* USBInfra */
N	MODULE_ID_UAC				= 234,		/* UAC */
N	MODULE_ID_UAVC				= 236,		/* UAVC	*/
N	MODULE_ID_UVC				= 238,		/* UVC */
N	MODULE_ID_MASSSTORH			= 252,		/* MassStorH */
N	MODULE_ID_HIDH				= 254,		/* HIDH	*/
N
N	/* Security: Module ID					Module Name */
N	MODULE_ID_MSDRMPD			= 228,		/* MsDrmPd */
N	
N	/* Video: Module ID						Module Name */
N	MODULE_ID_AVICODEC			= 240,		/* AVICodec	 */
N	MODULE_ID_MJPEG				= 242,		/* MJpegCodec  */
N	MODULE_ID_WIVICORE			= 244,		/* WiViCore	*/
N	MODULE_ID_WIVI				= 246,		/* WiViDec */	
N	MODULE_ID_AVCTRL			= 248,		/* AVControl */
N	MODULE_ID_AVIUTIL			= 250,		/* AVIUtility */
N	
N	/* Wireless Toy							Module Name */
N	MODULE_ID_WTCHAN			= 168,		/* WTChannel */
N	MODULE_ID_WTCMDSERV			= 170,		/* WTCMDService */
N	MODULE_ID_WTDISPLAY			= 172,		/* WTDisplay */
N	MODULE_ID_WTMEDIA			= 174,		/* WTMedia */
N	MODULE_ID_WTSYS				= 176,		/* WTSystem	 */
N	MODULE_ID_WTTRANS			= 178,		/* WTTransport */
N	/* ISD9160   							Module Name */
N	MODULE_ID_DRVCRC  				= 179,		/* CRC Generater*/
N	MODULE_ID_DRVSWPWM 				= 180,		/* SW PWM Driver*/
N	
N	// Module ID valid range: 0 ~ 255	
N} E_SYSINFRA_MODULE_ID;
N
N
N#endif /* __MODULE_ID_H__ */
L 15 "..\..\..\Include\System\SysInfra.h" 2
N#include "stdint.h"
N#include "core_cm0.h"
L 1 "..\..\..\..\CMSIS\CM0\CoreSupport\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V2.01
N * @date     06. December 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )                   
X#if 0L                   
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N#ifndef __CORE_CM0_H_GENERIC
S#define __CORE_CM0_H_GENERIC
S
S
S/** \mainpage CMSIS Cortex-M0
S   
S  This documentation describes the CMSIS Cortex-M Core Peripheral Access Layer.
S  It consists of:
S 
S     - Cortex-M Core Register Definitions
S     - Cortex-M functions
S     - Cortex-M instructions
S 
S  The CMSIS Cortex-M0 Core Peripheral Access Layer contains C and assembly functions that ease 
S  access to the Cortex-M Core
S */ 
S
S/** \defgroup CMSIS_LintCinfiguration CMSIS Lint Configuration
S  List of Lint messages which will be suppressed and not shown:
S    - not yet checked
S  .
S  Note:  To re-enable a Message, insert a space before 'lint' *
S 
S */
S
S
S/*******************************************************************************
S *                 CMSIS definitions
S ******************************************************************************/
S/** \defgroup CMSIS_core_definitions CMSIS Core Definitions
S  This file defines all structures and symbols for CMSIS core:
S   - CMSIS version number
S   - Cortex-M core 
S   - Cortex-M core Revision Number
S  @{
S */
S
S/*  CMSIS CM0 definitions */
S#define __CM0_CMSIS_VERSION_MAIN  (0x02)                                                       /*!< [31:16] CMSIS HAL main version */
S#define __CM0_CMSIS_VERSION_SUB   (0x00)                                                       /*!< [15:0]  CMSIS HAL sub version  */
S#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | __CM0_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
S
S#define __CORTEX_M                (0x00)                                                       /*!< Cortex core                    */
S
S
S#if defined ( __CC_ARM   )
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
S
S#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S
S#endif
S
S#include <stdint.h>                      /*!< standard types definitions                      */
S#include "core_cmInstr.h"                /*!< Core Instruction Access                         */
S#include "core_cmFunc.h"                 /*!< Core Function Access                            */
S
N#endif /* __CORE_CM0_H_GENERIC */
N
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
S#define __CORE_CM0_H_DEPENDANT
S
S/* IO definitions (access restrictions to peripheral registers) */
S#ifdef __cplusplus
S  #define     __I     volatile           /*!< defines 'read only' permissions                 */
S#else
S  #define     __I     volatile const     /*!< defines 'read only' permissions                 */
S#endif
S#define     __O     volatile             /*!< defines 'write only' permissions                */
S#define     __IO    volatile             /*!< defines 'read / write' permissions              */
S
S/*@} end of group CMSIS_core_definitions */
S
S
S
S/*******************************************************************************
S *                 Register Abstraction
S ******************************************************************************/
S/** \defgroup CMSIS_core_register CMSIS Core Register
S  Core Register contain:
S  - Core Register
S  - Core NVIC Register
S  - Core SCB Register
S  - Core SysTick Register
S  - Core Debug Register
S*/
S
S/** \ingroup  CMSIS_core_register   
S    \defgroup CMSIS_CORE CMSIS Core
S  Type definitions for the Cortex-M Core Registers
S  @{
S */
S
S/** \brief  Union type to access the Application Program Status Register (APSR).
S */
Stypedef union
S{
S  struct
S  {
S#if (__CORTEX_M != 0x04)
S    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
S#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
S#endif
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */ 
S} APSR_Type;
S
S
S/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
S    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} IPSR_Type;
S
S
S/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
S#if (__CORTEX_M != 0x04)
S    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
S#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
S#endif
S    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
S    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} xPSR_Type;
S
S
S/** \brief  Union type to access the Control Registers (CONTROL).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
S    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
S    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
S    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} CONTROL_Type;
S
S/*@} end of group CMSIS_CORE */
S
S
S/** \ingroup  CMSIS_core_register   
S    \defgroup CMSIS_NVIC CMSIS NVIC
S  Type definitions for the Cortex-M NVIC Registers
S  @{
S */
S
S/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
S */
Stypedef struct
S{
S  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
S       uint32_t RESERVED0[31];
S  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
S       uint32_t RSERVED1[31];
S  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
S       uint32_t RESERVED2[31];
S  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
S       uint32_t RESERVED3[31];
S       uint32_t RESERVED4[64];
S  __IO uint32_t IPR[8];                  /*!< Offset: 0x3EC (R/W)  Interrupt Priority Register              */
S}  NVIC_Type;
S
S/*@} end of group CMSIS_NVIC */
S
S
S/** \ingroup  CMSIS_core_register   
S    \defgroup CMSIS_SCB CMSIS SCB
S  Type definitions for the Cortex-M System Control Block Registers
S  @{
S */
S
S/** \brief  Structure type to access the System Control Block (SCB).
S */
Stypedef struct
S{
S  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPU ID Base Register                                  */
S  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control State Register                      */
S       uint32_t RESERVED0;                                      
S  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt / Reset Control Register        */
S  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
S  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
S       uint32_t RESERVED1;                                      
S  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
S  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
S       uint32_t RESERVED2[2];                                   
S  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
S} SCB_Type;                                                
S
S/* SCB CPUID Register Definitions */
S#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
S#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
S
S#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
S#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
S
S#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
S#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
S
S#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
S#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
S
S#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
S#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
S
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
S#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
S
S#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
S#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
S
S#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
S#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
S
S#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
S#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
S
S#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
S#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
S
S#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
S#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
S
S#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
S#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
S
S#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
S#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
S
S#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
S#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
S
S/* SCB Application Interrupt and Reset Control Register Definitions */
S#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
S#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
S
S#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
S#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
S
S#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
S#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
S
S#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
S#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
S
S#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
S#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
S
S/* SCB System Control Register Definitions */
S#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
S#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
S
S#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
S#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
S
S#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
S#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
S
S/* SCB Configuration Control Register Definitions */
S#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
S#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
S
S#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
S#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
S
S/* SCB System Handler Control and State Register Definitions */
S#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
S#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
S
S/* SCB Debug Fault Status Register Definitions */
S#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
S#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
S
S#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
S#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
S
S#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
S#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
S
S#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
S#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
S
S#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
S#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
S
S/*@} end of group CMSIS_SCB */
S
S
S/** \ingroup  CMSIS_core_register   
S    \defgroup CMSIS_SysTick CMSIS SysTick
S  Type definitions for the Cortex-M System Timer Registers
S  @{
S */
S
S/* SysTick constants - copied from \Keil\ARM\RV31\INC\core_cm0.h */
S#define SYSTICK_ENABLE              0                                          /* Config-Bit to start or stop the SysTick Timer                         */
S#define SYSTICK_TICKINT             1                                          /* Config-Bit to enable or disable the SysTick interrupt                 */
S#define SYSTICK_CLKSOURCE           2                                          /* Clocksource has the offset 2 in SysTick Control and Status Register   */
S#define SYSTICK_MAXCOUNT       ((1<<24) -1)                                    /* SysTick MaxCount                                                      */
S
S/** \brief  Structure type to access the System Timer (SysTick).
S */
Stypedef struct
S{
S  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
S  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
S  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
S  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
S} SysTick_Type;
S
S/* SysTick Control / Status Register Definitions */
S#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
S#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
S
S#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
S#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
S
S#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
S#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
S
S#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
S#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
S
S/* SysTick Reload Register Definitions */
S#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
S#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
S
S/* SysTick Current Register Definitions */
S#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
S#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
S
S/* SysTick Calibration Register Definitions */
S#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
S#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
S
S#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
S#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
S
S#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
S#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
S
S/*@} end of group CMSIS_SysTick */
S
S
S/** \ingroup  CMSIS_core_register   
S    \defgroup CMSIS_CoreDebug CMSIS Core Debug
S  Type definitions for the Cortex-M Core Debug Registers
S  @{
S */
S
S/** \brief  Structure type to access the Core Debug Register (CoreDebug).
S */
Stypedef struct
S{
S  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
S  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
S  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
S  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
S} CoreDebug_Type;
S
S/* Debug Halting Control and Status Register */
S#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
S#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
S
S#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
S#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
S
S#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
S#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
S
S#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
S#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
S
S#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
S#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
S
S#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
S#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
S
S#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
S#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
S
S#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
S#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
S
S#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
S#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
S
S#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
S#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
S
S#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
S#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
S
S/* Debug Core Register Selector Register */
S#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
S#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
S
S#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
S#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
S
S/* Debug Exception and Monitor Control Register */
S#define CoreDebug_DEMCR_DWTENA_Pos         24                                             /*!< CoreDebug DEMCR: DWTENA Position */
S#define CoreDebug_DEMCR_DWTENA_Msk         (1UL << CoreDebug_DEMCR_DWTENA_Pos)            /*!< CoreDebug DEMCR: DWTENA Mask */
S
S#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
S#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
S
S#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
S#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
S
S/*@} end of group CMSIS_CoreDebug */
S
S
S/** \ingroup  CMSIS_core_register   
S  @{
S */
S 
S/* Memory mapping of Cortex-M0 Hardware */
S#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
S#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address           */
S#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
S#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
S#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
S
S#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
S#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
S#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
S#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
S
S/*@} */
S
S
S
S/*******************************************************************************
S *                Hardware Abstraction Layer
S ******************************************************************************/
S/** \defgroup CMSIS_Core_FunctionInterface CMSIS Core Function Interface
S  Core Function Interface contains:
S  - Core NVIC Functions
S  - Core SysTick Functions
S  - Core Register Access Functions
S*/
S
S
S
S/* ##########################   NVIC functions  #################################### */
S/** \ingroup  CMSIS_Core_FunctionInterface   
S    \defgroup CMSIS_Core_NVICFunctions CMSIS Core NVIC Functions
S  @{
S */
S
S/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
S/* The following MACROS handle generation of the register offset and byte masks */
S#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
S#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
S#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
S
S
S/** \brief  Enable External Interrupt
S
S    This function enables a device specific interupt in the NVIC interrupt controller.
S    The interrupt number cannot be a negative value. 
S
S    \param [in]      IRQn  Number of the external interrupt to enable
S */
Sstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
S}
S
S
S/** \brief  Disable External Interrupt
S
S    This function disables a device specific interupt in the NVIC interrupt controller.
S    The interrupt number cannot be a negative value. 
S
S    \param [in]      IRQn  Number of the external interrupt to disable
S */
Sstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
S}
S
S
S/** \brief  Get Pending Interrupt
S
S    This function reads the pending register in the NVIC and returns the pending bit
S    for the specified interrupt. 
S
S    \param [in]      IRQn  Number of the interrupt for get pending
S    \return             0  Interrupt status is not pending
S    \return             1  Interrupt status is pending
S */
Sstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
S{
S  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
S}
S
S
S/** \brief  Set Pending Interrupt
S
S    This function sets the pending bit for the specified interrupt. 
S    The interrupt number cannot be a negative value.
S
S    \param [in]      IRQn  Number of the interrupt for set pending
S */
Sstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
S}
S
S
S/** \brief  Clear Pending Interrupt
S
S    This function clears the pending bit for the specified interrupt. 
S    The interrupt number cannot be a negative value.
S
S    \param [in]      IRQn  Number of the interrupt for clear pending
S */
Sstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
S}
S
S
S/** \brief  Set Interrupt Priority
S
S    This function sets the priority for the specified interrupt. The interrupt 
S    number can be positive to specify an external (device specific) 
S    interrupt, or negative to specify an internal (core) interrupt.
S
S    Note: The priority cannot be set for every core interrupt.
S
S    \param [in]      IRQn  Number of the interrupt for set priority
S    \param [in]  priority  Priority to set
S */
Sstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
S{
S  if(IRQn < 0) {
S    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) | 
S        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
S  else {
S    NVIC->IPR[_IP_IDX(IRQn)] = (NVIC->IPR[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
S        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
S}
S
S
S/** \brief  Get Interrupt Priority
S
S    This function reads the priority for the specified interrupt. The interrupt 
S    number can be positive to specify an external (device specific) 
S    interrupt, or negative to specify an internal (core) interrupt.
S
S    The returned priority value is automatically aligned to the implemented
S    priority bits of the microcontroller.
S
S    \param [in]   IRQn  Number of the interrupt for get priority
S    \return             Interrupt Priority
S */
Sstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
S{
S
S  if(IRQn < 0) {
S    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
S  else {
S    return((uint32_t)((NVIC->IPR[_IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
S}
S
S
S/** \brief  System Reset
S
S    This function initiate a system reset request to reset the MCU.
S */
Sstatic __INLINE void NVIC_SystemReset(void)
S{
S  __DSB();                                                     /* Ensure all outstanding memory accesses included
S                                                                  buffered write are completed before reset */              
S  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      | 
S                 SCB_AIRCR_SYSRESETREQ_Msk);
S  __DSB();                                                     /* Ensure completion of memory access */              
S  while(1);                                                    /* wait until reset */
S}
S
S/*@} end of CMSIS_Core_NVICFunctions */
S
S
S
S/* ##################################    SysTick function  ############################################ */
S/** \ingroup  CMSIS_Core_FunctionInterface   
S    \defgroup CMSIS_Core_SysTickFunctions CMSIS Core SysTick Functions
S  @{
S */
S
S#if (__Vendor_SysTickConfig == 0)
S
S/** \brief  System Tick Configuration
S
S    This function initialises the system tick timer and its interrupt and start the system tick timer.
S    Counter is in free running mode to generate periodical interrupts.
S
S    \param [in]  ticks  Number of ticks between two interrupts
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
Sstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
S{ 
S  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
S                                                               
S  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
S  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
S  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
S  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
S                   SysTick_CTRL_TICKINT_Msk   | 
S                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
S  return (0);                                                  /* Function successful */
S}
S
S#endif
S
S/*@} end of CMSIS_Core_SysTickFunctions */
S
S
S
S
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
N
N/*lint -restore */
L 17 "..\..\..\Include\System\SysInfra.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Version number								                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define SYSINFRA_MAJOR_NUM		1
N#define SYSINFRA_MINOR_NUM		00
N#define SYSINFRA_BUILD_NUM		1
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro, type and constant definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define an error code composed of error bit, module ID, and error ID. */
N#define _SYSINFRA_ERRCODE(IS_ERROR, MODULE_ID_VALUE, ERROR_ID)      (((IS_ERROR) ? 0xFFFF0000 : 0x00000000) | ((((MODULE_ID_VALUE) & 0xFF) | ((IS_ERROR) ? 0x100 : 0x00)) << 7) | ((ERROR_ID) & 0x7F))
N#define _SYSINFRA_ERRCODE_DEF(MODULE_ID, ERROR_NAME, IS_ERROR, MODULE_ID_VALUE, ERROR_ID) enum {E_##MODULE_ID##_##ERROR_NAME = ((IS_ERROR) ? 0xFFFF0000 : 0x00000000) | ((((MODULE_ID_VALUE) & 0xFF) | ((IS_ERROR) ? 0x100 : 0x00)) << 7) | ((ERROR_ID) & 0x7F)};
N
N/* Define a module version composed of major number, minor number, and build number. */
N#define _SYSINFRA_VERSION(MAJOR_NUM, MINOR_NUM, BUILD_NUM)          (((MAJOR_NUM) << 16) | ((MINOR_NUM) << 8) | (BUILD_NUM))
N#define _SYSINFRA_VERSION_DEF(MODULE_ID, MAJOR_NUM, MINOR_NUM, BUILD_NUM)	enum {MODULE_ID##_VERSION_NUM = ((MAJOR_NUM) << 16) | ((MINOR_NUM) << 8) | (BUILD_NUM)};
N
N/* Test if this error code means an error by seeing its error bit (BIT31). */
N#define _SYSINFRA_ERRCODE_IS_ERROR(ERROR_CODE)	((ERROR_CODE) < 0)
N/* Extract module ID part of this error code. */
N#define _SYSINFRA_ERRCODE_EXTRACT_MODULE_ID(ERROR_CODE)	(((ERROR_CODE) >> 7) & 0xFF)
N/* Extract error ID part of this error code. */
N#define _SYSINFRA_ERRCODE_EXTRACT_ERROR_ID(ERROR_CODE)	((ERROR_CODE) & 0x7F)
N
N/* Define module version number.*/
N#define SYSINFRA_VERSION_NUM    _SYSINFRA_VERSION(SYSINFRA_MAJOR_NUM, SYSINFRA_MINOR_NUM, SYSINFRA_BUILD_NUM)
N
N#define E_SUCCESS		0
N#define S_OK			E_SUCCESS
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Error Code									                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N/* #define Error Code */
N//E_SYSINFRA_NOT_DEFINE					Un-defined error code	
N//E_SYSINFRA_NULL_POINTER				A NULL pointer is passed as an argument
N//E_SYSINFRA_BUFFER_OVERRUN				Buffer size is not enough
N
N#define E_SYSINFRA_NOT_DEFINE       _SYSINFRA_ERRCODE(TRUE, MODULE_ID_SYSINFRA, 0)
N#define E_SYSINFRA_NULL_POINTER     _SYSINFRA_ERRCODE(TRUE, MODULE_ID_SYSINFRA, 1)
N#define E_SYSINFRA_BUFFER_OVERRUN   _SYSINFRA_ERRCODE(TRUE, MODULE_ID_SYSINFRA, 2)
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // __SYSINFRA_H__
N
N
N
L 104 "..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\ISD93xx\isd93xx.h" 2
N
N
N
N/**
N * Initialize the system clock
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system
N *         Initialize the Oscillator and update the SystemFrequency variable
N */
Nextern void SystemInit (void);
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N/** @addtogroup ISD91XX_Peripherals ISD91XX Peripherals
N    ISD91XX Device Specific Peripheral registers structures
N    @{
N*/
N
N/*--------------------- General Purpose Input and Ouptut ---------------------*/
N/** @addtogroup ISD91XX_GPIO ISD91XX GPIO Control Registers (GPIO)
N    @{
N*/
Ntypedef struct
N{
N    __IO uint32_t PMD0:2;
X    volatile uint32_t PMD0:2;
N    __IO uint32_t PMD1:2;
X    volatile uint32_t PMD1:2;
N    __IO uint32_t PMD2:2;
X    volatile uint32_t PMD2:2;
N    __IO uint32_t PMD3:2;
X    volatile uint32_t PMD3:2;
N    __IO uint32_t PMD4:2;
X    volatile uint32_t PMD4:2;
N    __IO uint32_t PMD5:2;
X    volatile uint32_t PMD5:2;
N    __IO uint32_t PMD6:2;
X    volatile uint32_t PMD6:2;
N    __IO uint32_t PMD7:2;
X    volatile uint32_t PMD7:2;
N    __IO uint32_t PMD8:2;
X    volatile uint32_t PMD8:2;
N    __IO uint32_t PMD9:2;
X    volatile uint32_t PMD9:2;
N    __IO uint32_t PMD10:2;
X    volatile uint32_t PMD10:2;
N    __IO uint32_t PMD11:2;
X    volatile uint32_t PMD11:2;
N    __IO uint32_t PMD12:2;
X    volatile uint32_t PMD12:2;
N    __IO uint32_t PMD13:2;
X    volatile uint32_t PMD13:2;
N    __IO uint32_t PMD14:2;
X    volatile uint32_t PMD14:2;
N    __IO uint32_t PMD15:2;
X    volatile uint32_t PMD15:2;
N} GPIO_PMD_T;
N
Ntypedef __IO uint32_t GPIO_INDIS_T;
Xtypedef volatile uint32_t GPIO_INDIS_T;
Ntypedef __IO uint32_t GPIO_DOUT_T;
Xtypedef volatile uint32_t GPIO_DOUT_T;
Ntypedef __IO uint32_t GPIO_DMASK_T;
Xtypedef volatile uint32_t GPIO_DMASK_T;
Ntypedef __IO uint32_t GPIO_PIN_T;
Xtypedef volatile uint32_t GPIO_PIN_T;
Ntypedef __IO uint32_t GPIO_DBEN_T;
Xtypedef volatile uint32_t GPIO_DBEN_T;
Ntypedef __IO uint32_t GPIO_IMD_T;
Xtypedef volatile uint32_t GPIO_IMD_T;
Ntypedef __IO uint32_t GPIO_IEN_T;
Xtypedef volatile uint32_t GPIO_IEN_T;
Ntypedef __IO uint32_t GPIO_ISRC_T;
Xtypedef volatile uint32_t GPIO_ISRC_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DBCLKSEL:4;
X    volatile uint32_t  DBCLKSEL:4;
N    __IO uint32_t  DBCLKSRC:1;
X    volatile uint32_t  DBCLKSRC:1;
N    __IO uint32_t  ICLK_ON:1;
X    volatile uint32_t  ICLK_ON:1;
N    __I  uint32_t  RESERVE:26;
X    volatile const  uint32_t  RESERVE:26;
N} GPIO_DBNCECON_T;
N
Ntypedef struct
N{
N    GPIO_PMD_T      PMD;                 /*!< Offset: 0x0000   GPIO Mode Control Register           */
N    GPIO_INDIS_T    INDIS;               /*!< Offset: 0x0004   GPIO Input Disable Register          */
N    GPIO_DOUT_T     DOUT;                /*!< Offset: 0x0008   GPIO Data Output Value Register      */
N    GPIO_DMASK_T    DMASK;               /*!< Offset: 0x000C   GPIO Data Output Write Mask Register */
N    GPIO_PIN_T      PIN;                 /*!< Offset: 0x0010   GPIO Pin Value Register              */
N    GPIO_DBEN_T     DBEN;                /*!< Offset: 0x0014   GPIO De-bounce Enable Register       */
N    GPIO_IMD_T      IMD;                 /*!< Offset: 0x0018   GPIO Interrupt Mode Control          */
N    GPIO_IEN_T      IEN;                 /*!< Offset: 0x001C   GPIO Interrupt Enable Control        */
N    GPIO_ISRC_T     ISRC;                /*!< Offset: 0x0020   GPIO Interrupt Source                */
N
N} GPIO_T;
N/*@}*/ /* end of group ISD91XX_GPIO */
N
N/*------------------------- UART Interface Controller ------------------------*/
N
Ntypedef __IO uint8_t UART_DATA_T;
Xtypedef volatile uint8_t UART_DATA_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  RDA_IEN:1;
X    volatile uint32_t  RDA_IEN:1;
N    __IO uint32_t  THRE_IEN:1;
X    volatile uint32_t  THRE_IEN:1;
N    __IO uint32_t  RLS_IEN:1;
X    volatile uint32_t  RLS_IEN:1;
N    __IO uint32_t  MS_IEN:1;
X    volatile uint32_t  MS_IEN:1;
N    __IO uint32_t  RTO_IEN:1;
X    volatile uint32_t  RTO_IEN:1;
N    __IO uint32_t  BUF_ERR_IEN:1;
X    volatile uint32_t  BUF_ERR_IEN:1;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  LIN_RX_BRK_IEN:1;
X    volatile uint32_t  LIN_RX_BRK_IEN:1;
N    __I  uint32_t  RESERVE1:2;
X    volatile const  uint32_t  RESERVE1:2;
N    __IO uint32_t  TOC_EN:1;      /* Time-out counter enable */
X    volatile uint32_t  TOC_EN:1;       
N    __IO uint32_t  AUTO_RTS_EN:1;
X    volatile uint32_t  AUTO_RTS_EN:1;
N    __IO uint32_t  AUTO_CTS_EN:1;
X    volatile uint32_t  AUTO_CTS_EN:1;
N    __IO uint32_t  DMA_TX_EN:1;
X    volatile uint32_t  DMA_TX_EN:1;
N    __IO uint32_t  DMA_RX_EN:1;
X    volatile uint32_t  DMA_RX_EN:1;
N    __I  uint32_t  RESERVE2:15;
X    volatile const  uint32_t  RESERVE2:15;
N    __IO uint32_t  nDEBUGACK_EN:1;
X    volatile uint32_t  nDEBUGACK_EN:1;
N} UART_IER_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  RFR:1;
X    volatile uint32_t  RFR:1;
N    __IO uint32_t  TFR:1;
X    volatile uint32_t  TFR:1;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __IO uint32_t  RFITL:4;             /* Rx FIFO Interrupt Trigger Level */
X    volatile uint32_t  RFITL:4;              
N    __I  uint32_t  RESERVE2:8;
X    volatile const  uint32_t  RESERVE2:8;
N    __IO uint32_t  RTS_TRIG_LEVEL:4;
X    volatile uint32_t  RTS_TRIG_LEVEL:4;
N    __I  uint32_t  RESERVE3:12;
X    volatile const  uint32_t  RESERVE3:12;
N} UART_FCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  WLS:2;               /* Word length select */
X    volatile uint32_t  WLS:2;                
N    __IO uint32_t  NSB:1;               /* Number of STOP bit */
X    volatile uint32_t  NSB:1;                
N    __IO uint32_t  PBE:1;               /* Parity bit enable  */
X    volatile uint32_t  PBE:1;                
N    __IO uint32_t  EPE:1;               /* Even parity enable */
X    volatile uint32_t  EPE:1;                
N    __IO uint32_t  SPE:1;               /* Stick parity enable*/
X    volatile uint32_t  SPE:1;                
N    __IO uint32_t  BCB:1;               /* Break control bit  */
X    volatile uint32_t  BCB:1;                
N    __I  uint32_t  RESERVE:25;
X    volatile const  uint32_t  RESERVE:25;
N} UART_LCR_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  RTS_SET:1;
X    volatile uint32_t  RTS_SET:1;
N    __I  uint32_t  RESERVE1:2;
X    volatile const  uint32_t  RESERVE1:2;
N    __IO uint32_t  LBME:1;
X    volatile uint32_t  LBME:1;
N    __I  uint32_t  RESERVE2:4;
X    volatile const  uint32_t  RESERVE2:4;
N    __IO uint32_t  RTS_ACT:1;
X    volatile uint32_t  RTS_ACT:1;
N    __I  uint32_t  RESERVE3:3;
X    volatile const  uint32_t  RESERVE3:3;
N    __I  uint32_t  RTS_ST:1;               /* RTS status */
X    volatile const  uint32_t  RTS_ST:1;                
N    __I  uint32_t  RESERVE4:18;
X    volatile const  uint32_t  RESERVE4:18;
N} UART_MCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DCTS:1;
X    volatile uint32_t  DCTS:1;
N    __I  uint32_t  RESERVE0:3;
X    volatile const  uint32_t  RESERVE0:3;
N    __I  uint32_t  CTS:1;               /* CTS status */
X    volatile const  uint32_t  CTS:1;                
N    __I  uint32_t  RESERVE1:3;
X    volatile const  uint32_t  RESERVE1:3;
N    __IO uint32_t  CTS_ACT:1;
X    volatile uint32_t  CTS_ACT:1;
N    __I  uint32_t  RESERVE2:23;
X    volatile const  uint32_t  RESERVE2:23;
N} UART_MSR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  RX_OVF_IF:1;
X    volatile uint32_t  RX_OVF_IF:1;
N    __I  uint32_t  RESERVE0:3;
X    volatile const  uint32_t  RESERVE0:3;
N    __IO uint32_t  PEF:1;
X    volatile uint32_t  PEF:1;
N    __IO uint32_t  FEF:1;
X    volatile uint32_t  FEF:1;
N    __IO uint32_t  BIF:1;
X    volatile uint32_t  BIF:1;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __I  uint32_t  RX_POINTER:6;
X    volatile const  uint32_t  RX_POINTER:6;
N    __I  uint32_t  RX_EMPTY:1;
X    volatile const  uint32_t  RX_EMPTY:1;
N    __I  uint32_t  RX_FULL:1;
X    volatile const  uint32_t  RX_FULL:1;
N    __I  uint32_t  TX_POINTER:6;
X    volatile const  uint32_t  TX_POINTER:6;
N    __I  uint32_t  TX_EMPTY:1;
X    volatile const  uint32_t  TX_EMPTY:1;
N    __I  uint32_t  TX_FULL:1;
X    volatile const  uint32_t  TX_FULL:1;
N    __IO uint32_t  TX_OVF_IF:1;
X    volatile uint32_t  TX_OVF_IF:1;
N    __I  uint32_t  RESERVE2:3;
X    volatile const  uint32_t  RESERVE2:3;
N    __I  uint32_t  TE:1;                /* Transmitter empty */
X    volatile const  uint32_t  TE:1;                 
N    __I  uint32_t  RESERVE3:3;
X    volatile const  uint32_t  RESERVE3:3;
N} UART_FSR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  RDA_IF:1;
X    volatile uint32_t  RDA_IF:1;
N    __IO uint32_t  THRE_IF:1;
X    volatile uint32_t  THRE_IF:1;
N    __IO uint32_t  RLS_IF:1;
X    volatile uint32_t  RLS_IF:1;
N    __IO uint32_t  MODEM_IF:1;
X    volatile uint32_t  MODEM_IF:1;
N    __IO uint32_t  TOUT_IF:1;
X    volatile uint32_t  TOUT_IF:1;
N    __IO uint32_t  BUF_ERR_IF:1;
X    volatile uint32_t  BUF_ERR_IF:1;
N    __IO uint32_t  WAKE_IF:1;
X    volatile uint32_t  WAKE_IF:1;
N    __IO uint32_t  LIN_Rx_Break_IF:1;
X    volatile uint32_t  LIN_Rx_Break_IF:1;
N    __IO uint32_t  RDA_INT:1;
X    volatile uint32_t  RDA_INT:1;
N    __IO uint32_t  THRE_INT:1;
X    volatile uint32_t  THRE_INT:1;
N    __IO uint32_t  RLS_INT:1;
X    volatile uint32_t  RLS_INT:1;
N    __IO uint32_t  MODEM_INT:1;
X    volatile uint32_t  MODEM_INT:1;
N    __IO uint32_t  TOUT_INT:1;
X    volatile uint32_t  TOUT_INT:1;
N    __IO uint32_t  BUF_ERR_INT:1;
X    volatile uint32_t  BUF_ERR_INT:1;
N    __IO uint32_t  WAKE_INT:1;
X    volatile uint32_t  WAKE_INT:1;
N    __IO uint32_t  LIN_Rx_Break_INT:1;
X    volatile uint32_t  LIN_Rx_Break_INT:1;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  DMA_RLS_IF:1;
X    volatile uint32_t  DMA_RLS_IF:1;
N    __IO uint32_t  DMA_MODEM_IF:1;
X    volatile uint32_t  DMA_MODEM_IF:1;
N    __IO uint32_t  DMA_TOUT_IF:1;
X    volatile uint32_t  DMA_TOUT_IF:1;
N    __IO uint32_t  DMA_BUF_ERR_IF:1;
X    volatile uint32_t  DMA_BUF_ERR_IF:1;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __IO uint32_t  DMA_LIN_Rx_Break_IF:1;
X    volatile uint32_t  DMA_LIN_Rx_Break_IF:1;
N    __I  uint32_t  RESERVE2:2;
X    volatile const  uint32_t  RESERVE2:2;
N    __IO uint32_t  DMA_RLS_INT:1;
X    volatile uint32_t  DMA_RLS_INT:1;
N    __IO uint32_t  DMA_MODEM_INT:1;
X    volatile uint32_t  DMA_MODEM_INT:1;
N    __IO uint32_t  DMA_TOUT_INT:1;
X    volatile uint32_t  DMA_TOUT_INT:1;
N    __IO uint32_t  DMA_BUF_ERR_INT:1;
X    volatile uint32_t  DMA_BUF_ERR_INT:1;
N    __I  uint32_t  RESERVE3:1;
X    volatile const  uint32_t  RESERVE3:1;
N    __IO uint32_t  DMA_LIN_Rx_Break_INT:1;
X    volatile uint32_t  DMA_LIN_Rx_Break_INT:1;
N} UART_ISR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TOIC:7;
X    volatile uint32_t  TOIC:7;
N    __I  uint32_t  RESERVE0:25;
X    volatile const  uint32_t  RESERVE0:25;
N} UART_TOR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  BRD:16;
X    volatile uint32_t  BRD:16;
N    __I  uint32_t  RESERVE0:8;
X    volatile const  uint32_t  RESERVE0:8;
N    __IO uint32_t  DIVX:4;
X    volatile uint32_t  DIVX:4;
N    __IO uint32_t  DIVX_ONE:1;
X    volatile uint32_t  DIVX_ONE:1;
N    __IO uint32_t  DIVX_EN:1;
X    volatile uint32_t  DIVX_EN:1;
N    __I  uint32_t  RESERVE1:2;
X    volatile const  uint32_t  RESERVE1:2;
N} UART_BAUD_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  TX_SELECT:1;
X    volatile uint32_t  TX_SELECT:1;
N    __IO uint32_t  LOOPBACK:1;
X    volatile uint32_t  LOOPBACK:1;
N    __IO uint32_t  RX_DEB_EN:1;
X    volatile uint32_t  RX_DEB_EN:1;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __IO uint32_t  TX_INV_EN:1;
X    volatile uint32_t  TX_INV_EN:1;
N    __IO uint32_t  RX_INV_EN:1;
X    volatile uint32_t  RX_INV_EN:1;
N    __I  uint32_t  RESERVE2:25;
X    volatile const  uint32_t  RESERVE2:25;
N} UART_IRCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  LINBCNT:4;
X    volatile uint32_t  LINBCNT:4;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  LINRX_EN:1;
X    volatile uint32_t  LINRX_EN:1;
N    __IO uint32_t  LINTX_EN:1;
X    volatile uint32_t  LINTX_EN:1;
N    __I  uint32_t  RESERVE1:24;
X    volatile const  uint32_t  RESERVE1:24;
N} UART_LINCON_T;
N
N
N
Ntypedef struct
N{
N    __IO uint32_t  LIN_EN:1;
X    volatile uint32_t  LIN_EN:1;
N    __IO uint32_t  IrDA_EN:1;
X    volatile uint32_t  IrDA_EN:1;
N    __I  uint32_t  RESERVE0:30;
X    volatile const  uint32_t  RESERVE0:30;
N} UART_FUNSEL_T;
N
N
Ntypedef struct
N{
N    UART_DATA_T     DATA;
N    __I  uint8_t    RESERVE0[3];
X    volatile const  uint8_t    RESERVE0[3];
N    UART_IER_T      IER;
N    UART_FCR_T      FCR;
N    UART_LCR_T      LCR;
N    UART_MCR_T      MCR;
N    UART_MSR_T      MSR;
N    UART_FSR_T      FSR;
N    UART_ISR_T      ISR;
N    UART_TOR_T      TOR;
N    UART_BAUD_T     BAUD;
N    UART_IRCR_T     IRCR;
N    UART_LINCON_T   LINCON;
N    UART_FUNSEL_T   FUNSEL;
N} UART_T;
N
N/*----------------------------- Timer Controller -----------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  PRESCALE:8;
X    volatile uint32_t  PRESCALE:8;
N    __I  uint32_t  RESERVE0:8;
X    volatile const  uint32_t  RESERVE0:8;
N    __IO uint32_t  TDR_EN:1;
X    volatile uint32_t  TDR_EN:1;
N    __I  uint32_t  RESERVE1:8;
X    volatile const  uint32_t  RESERVE1:8;
N    __IO uint32_t  CACT:1;
X    volatile uint32_t  CACT:1;
N    __IO uint32_t  CRST:1;
X    volatile uint32_t  CRST:1;
N    __IO uint32_t  MODE:2;
X    volatile uint32_t  MODE:2;
N    __IO uint32_t  IE:1;
X    volatile uint32_t  IE:1;
N    __IO uint32_t  CEN:1;
X    volatile uint32_t  CEN:1;
N    __IO uint32_t  nDBGACK_EN:1;
X    volatile uint32_t  nDBGACK_EN:1;
N} TIMER_TCSR_T;
N
Ntypedef __IO uint32_t TIMER_TCMPR_T;
Xtypedef volatile uint32_t TIMER_TCMPR_T;
N
Ntypedef __IO uint32_t TIMER_TDR_T;
Xtypedef volatile uint32_t TIMER_TDR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TIF:1;
X    volatile uint32_t  TIF:1;
N    __I  uint32_t  RESERVE:31;
X    volatile const  uint32_t  RESERVE:31;
N} TIMER_TISR_T;
N
Ntypedef struct
N{
N    TIMER_TCSR_T     TCSR;
N    TIMER_TCMPR_T    TCMPR;
N    TIMER_TISR_T     TISR;
N    TIMER_TDR_T      TDR;
N} TIMER_T;
N
N
N/*----------------------------- WDT Controller -----------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  WTR:1;
X    volatile uint32_t  WTR:1;
N    __IO uint32_t  WTRE:1;
X    volatile uint32_t  WTRE:1;
N    __IO uint32_t  WTRF:1;
X    volatile uint32_t  WTRF:1;
N    __IO uint32_t  WTIF:1;
X    volatile uint32_t  WTIF:1;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  WTIE:1;
X    volatile uint32_t  WTIE:1;
N    __IO uint32_t  WTE:1;
X    volatile uint32_t  WTE:1;
N    __IO uint32_t  WTIS:3;
X    volatile uint32_t  WTIS:3;
N    __I  uint32_t  RESERVE1:21;
X    volatile const  uint32_t  RESERVE1:21;
N} WDT_WTCR_T;
N
Ntypedef struct
N{
N    WDT_WTCR_T     WTCR;
N
N} WDT_T;
N
N/*------------------------- SPI Interface Controller -------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  SPIEN:1;         // 0
X    volatile uint32_t  SPIEN:1;         
N    __IO uint32_t  RX_NEG:1;        // 1
X    volatile uint32_t  RX_NEG:1;        
N    __IO uint32_t  TX_NEG:1;        // 2
X    volatile uint32_t  TX_NEG:1;        
N    __IO uint32_t  CLKP:1;          // 3
X    volatile uint32_t  CLKP:1;          
N    __IO uint32_t  SP_CYCLE:4;      // 7:4
X    volatile uint32_t  SP_CYCLE:4;      
N    __IO uint32_t  DWIDTH:5;        // 12:8
X    volatile uint32_t  DWIDTH:5;        
N    __IO uint32_t  LSB:1;           // 13
X    volatile uint32_t  LSB:1;           
N    __IO uint32_t  RESERVE0:2;      // 15:14
X    volatile uint32_t  RESERVE0:2;      
N    __IO uint32_t  TWOB:1;          // 16
X    volatile uint32_t  TWOB:1;          
N    __IO uint32_t  UNIT_INTEN:1;    // 17
X    volatile uint32_t  UNIT_INTEN:1;    
N    __IO uint32_t  SLAVE:1;         // 18
X    volatile uint32_t  SLAVE:1;         
N    __IO uint32_t  REORDER:1;       // 19
X    volatile uint32_t  REORDER:1;       
N    __IO uint32_t  QD_IO_DIR:1;     // 20
X    volatile uint32_t  QD_IO_DIR:1;     
N    __IO uint32_t  DUAL_IO_EN:1;    // 21
X    volatile uint32_t  DUAL_IO_EN:1;    
N    __IO uint32_t  QUAD_IO_EN:1;    // 22
X    volatile uint32_t  QUAD_IO_EN:1;    
N    __IO uint32_t  RX_TRANS_CNT_EN:1;// 23
X    volatile uint32_t  RX_TRANS_CNT_EN:1;
N    __IO uint32_t  RX_MODE_EN:1;    // 24
X    volatile uint32_t  RX_MODE_EN:1;    
N    __I  uint32_t  RESERVE:7;       // 31:25
X    volatile const  uint32_t  RESERVE:7;       
N
N} SPI_CNTRL_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DIVIDER:8;
X    volatile uint32_t  DIVIDER:8;
N    __I  uint32_t  RESERVED:24;
X    volatile const  uint32_t  RESERVED:24;
N} SPI_DIVIDER_T;
N
Ntypedef struct
N{
N    __IO uint32_t  SSR:2;
X    volatile uint32_t  SSR:2;
N    __IO uint32_t  SS_LVL:1;
X    volatile uint32_t  SS_LVL:1;
N    __IO uint32_t  AUTO_SS:1;
X    volatile uint32_t  AUTO_SS:1;
N    __IO uint32_t  SLAVE_3WIRE:1;
X    volatile uint32_t  SLAVE_3WIRE:1;
N    __IO uint32_t  SLAVE_TIMEOUT_IE:1;
X    volatile uint32_t  SLAVE_TIMEOUT_IE:1;
N    __IO uint32_t  SLAVE_TIMEOUT_FIFO_CLR:1;
X    volatile uint32_t  SLAVE_TIMEOUT_FIFO_CLR:1;
N    __I  uint32_t  RESERVE7:1;
X    volatile const  uint32_t  RESERVE7:1;
N    __IO uint32_t  SLAVE_ERROR0_IE:1;
X    volatile uint32_t  SLAVE_ERROR0_IE:1;
N    __IO uint32_t  SLAVE_ERROR1_IE:1;
X    volatile uint32_t  SLAVE_ERROR1_IE:1;
N    __I  uint32_t  RESERVE10:2;
X    volatile const  uint32_t  RESERVE10:2;
N    __IO uint32_t  SS_ACTIVE_IE:1;
X    volatile uint32_t  SS_ACTIVE_IE:1;
N    __IO uint32_t  SS_INACTIVE_IE:1;
X    volatile uint32_t  SS_INACTIVE_IE:1;
N    __I  uint32_t  RESERVE14:2;
X    volatile const  uint32_t  RESERVE14:2;
N    __IO uint32_t  SLAVE_TIMEOUT_PERIOD:16;
X    volatile uint32_t  SLAVE_TIMEOUT_PERIOD:16;
N} SPI_SSR_T;
N
N
Ntypedef __I  uint32_t   SPI_RX_T;
Xtypedef volatile const  uint32_t   SPI_RX_T;
Ntypedef __O  uint32_t   SPI_TX_T;
Xtypedef volatile  uint32_t   SPI_TX_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TX_DMA_GO:1;
X    volatile uint32_t  TX_DMA_GO:1;
N    __IO uint32_t  RX_DMA_GO:1;
X    volatile uint32_t  RX_DMA_GO:1;
N    __IO uint32_t  DMA_RST:1;
X    volatile uint32_t  DMA_RST:1;
N    __I  uint32_t  RESERVE:29;
X    volatile const  uint32_t  RESERVE:29;
N} SPI_DMA_T;
N
Ntypedef struct
N{
N    __IO uint32_t  RX_CLR:1;
X    volatile uint32_t  RX_CLR:1;
N    __IO uint32_t  TX_CLR:1;
X    volatile uint32_t  TX_CLR:1;
N    __IO uint32_t  RXTH_INTEN:1;
X    volatile uint32_t  RXTH_INTEN:1;
N    __IO uint32_t  TXTH_INTEN:1;
X    volatile uint32_t  TXTH_INTEN:1;
N    __IO uint32_t  RXTO_INTEN:1;
X    volatile uint32_t  RXTO_INTEN:1;
N    __IO uint32_t  RXOVR_INTEN:1;
X    volatile uint32_t  RXOVR_INTEN:1;
N    __IO uint32_t  TXUDR_DO:1;
X    volatile uint32_t  TXUDR_DO:1;
N    __IO uint32_t  TXUDR_INTEN:1;
X    volatile uint32_t  TXUDR_INTEN:1;
N    __I  uint32_t  RESERVE8:16;
X    volatile const  uint32_t  RESERVE8:16;
N    __IO uint32_t  RX_THRESHOLD:3;
X    volatile uint32_t  RX_THRESHOLD:3;
N    __I  uint32_t  RESERVE27:1;
X    volatile const  uint32_t  RESERVE27:1;
N    __IO uint32_t  TX_THRESHOLD:3;
X    volatile uint32_t  TX_THRESHOLD:3;
N    __I  uint32_t  RESERVE31:1;
X    volatile const  uint32_t  RESERVE31:1;
N} SPI_FIFO_T;
N
Ntypedef struct
N{
N    __IO uint32_t  BUSY:1;            // 0
X    volatile uint32_t  BUSY:1;            
N    __IO uint32_t  UNIT_INTSTS:1;     // 1
X    volatile uint32_t  UNIT_INTSTS:1;     
N    __IO uint32_t  SSACT_INTSTS:1;    // 2
X    volatile uint32_t  SSACT_INTSTS:1;    
N    __IO uint32_t  SSINA_INTSTS:1;    // 3
X    volatile uint32_t  SSINA_INTSTS:1;    
N    __IO uint32_t  SS_LINE:1;         // 4
X    volatile uint32_t  SS_LINE:1;         
N    __IO uint32_t  SLVTO_INTSTS:1;    // 5
X    volatile uint32_t  SLVTO_INTSTS:1;    
N    __IO uint32_t  SLVER0_INTSTS:1;   // 6
X    volatile uint32_t  SLVER0_INTSTS:1;   
N    __IO uint32_t  SLVER1_INTSTS:1;   // 7
X    volatile uint32_t  SLVER1_INTSTS:1;   
N    __I  uint32_t  RX_EMPTY:1;        // 8
X    volatile const  uint32_t  RX_EMPTY:1;        
N    __I  uint32_t  RX_FULL:1;         // 9
X    volatile const  uint32_t  RX_FULL:1;         
N    __IO uint32_t  RXTH_INTSTS:1;     // 10
X    volatile uint32_t  RXTH_INTSTS:1;     
N    __IO uint32_t  RXOVR_INTSTS:1;    // 11
X    volatile uint32_t  RXOVR_INTSTS:1;    
N    __IO uint32_t  RXTO_INTSTS:1;     // 12
X    volatile uint32_t  RXTO_INTSTS:1;     
N    __I  uint32_t  RESERVE13:2;       // 14:13
X    volatile const  uint32_t  RESERVE13:2;       
N    __I  uint32_t  SPIEN_STS:1;       // 15
X    volatile const  uint32_t  SPIEN_STS:1;       
N    __I  uint32_t  TX_EMPTY:1;        // 16
X    volatile const  uint32_t  TX_EMPTY:1;        
N    __I  uint32_t  TX_FULL:1;         // 17
X    volatile const  uint32_t  TX_FULL:1;         
N    __IO uint32_t  TXTH_INTSTS:1;     // 18
X    volatile uint32_t  TXTH_INTSTS:1;     
N    __IO uint32_t  TXUDR_INTSTS:1;    // 19
X    volatile uint32_t  TXUDR_INTSTS:1;    
N    __I  uint32_t  RESERVE20:3;       // 22:20
X    volatile const  uint32_t  RESERVE20:3;       
N    __I  uint32_t  FIFO_CLR_STS:1;    // 23
X    volatile const  uint32_t  FIFO_CLR_STS:1;    
N    __I  uint32_t  RX_FIFO_COUNT:4;   // 27:24
X    volatile const  uint32_t  RX_FIFO_COUNT:4;   
N    __I  uint32_t  TX_FIFO_COUNT:4;   // 31:28
X    volatile const  uint32_t  TX_FIFO_COUNT:4;   
N} SPI_STATUS_T;
N
Ntypedef struct
N{
N    SPI_CNTRL_T     CNTRL;
N    SPI_DIVIDER_T   DIVIDER;
N    SPI_SSR_T       SSR;
N    SPI_DMA_T       DMA;
N    SPI_FIFO_T      FIFO_CTRL;
N    SPI_STATUS_T    STATUS;
N    uint16_t        RX_TRANS_CNT;
N    uint16_t        RESERVE_W;
N    uint32_t        RESERVE0x1C[1];
N    SPI_TX_T        TX;
N    uint32_t        RESERVE2[3];
N    SPI_RX_T        RX;
N    uint32_t        RESERVE3;
N    uint32_t        RESERVE4;
N} SPI_T;
N
N/*------------------------------ I2C Controller ------------------------------*/
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  AA:1;
X    volatile uint32_t  AA:1;
N    __IO uint32_t  SI:1;
X    volatile uint32_t  SI:1;
N    __IO uint32_t  STO:1;
X    volatile uint32_t  STO:1;
N    __IO uint32_t  STA:1;
X    volatile uint32_t  STA:1;
N    __IO uint32_t  ENSI:1;
X    volatile uint32_t  ENSI:1;
N    __IO uint32_t  EI:1;
X    volatile uint32_t  EI:1;
N    __I  uint32_t  RESERVE1:24;
X    volatile const  uint32_t  RESERVE1:24;
N} I2C_CON_T;
N
Ntypedef struct
N{
N    __IO uint32_t  GC:1;
X    volatile uint32_t  GC:1;
N    __IO uint32_t  ADDR:7;
X    volatile uint32_t  ADDR:7;
N    __I  uint32_t  RESERVE:24;
X    volatile const  uint32_t  RESERVE:24;
N} I2C_ADDR_T;
N
Ntypedef __IO uint32_t I2C_DATA_T;
Xtypedef volatile uint32_t I2C_DATA_T;
N
Ntypedef __I  uint32_t I2C_STATUS_T;
Xtypedef volatile const  uint32_t I2C_STATUS_T;
N
Ntypedef __IO uint32_t I2C_CLK_T;
Xtypedef volatile uint32_t I2C_CLK_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TIF:1;
X    volatile uint32_t  TIF:1;
N    __IO uint32_t  DIV4:1;
X    volatile uint32_t  DIV4:1;
N    __IO uint32_t  ENTI:1;
X    volatile uint32_t  ENTI:1;
N    __I  uint32_t  RESERVE:29;
X    volatile const  uint32_t  RESERVE:29;
N} I2C_TOC_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  ADM:7;
X    volatile uint32_t  ADM:7;
N    __I  uint32_t  RESERVE1:24;
X    volatile const  uint32_t  RESERVE1:24;
N} I2C_ADRM_T;
N
Ntypedef struct
N{
N    I2C_CON_T       CON;
N    I2C_ADDR_T      ADDR0;
N    I2C_DATA_T      DATA;
N    I2C_STATUS_T    STATUS;
N    I2C_CLK_T       CLK;
N    I2C_TOC_T       TOC;
N    I2C_ADDR_T	    ADDR1;
N    I2C_ADDR_T	    ADDR2;
N    I2C_ADDR_T	    ADDR3;
N    I2C_ADRM_T		ADRM0;
N    I2C_ADRM_T		ADRM1;
N    I2C_ADRM_T		ADRM2;
N    I2C_ADRM_T	    ADRM3;
N    __I uint32_t    DATE;
X    volatile const uint32_t    DATE;
N    __I uint32_t    VERSION;
X    volatile const uint32_t    VERSION;
N    __IO uint32_t   High_Speed;
X    volatile uint32_t   High_Speed;
N} I2C_T;
N
N
N/*----------------------------- RTC Controller -------------------------------*/
N
Ntypedef __IO uint32_t RTC_INIR_T;
Xtypedef volatile uint32_t RTC_INIR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  AER:16;
X    volatile uint32_t  AER:16;
N    __I  uint32_t  ENF:1;
X    volatile const  uint32_t  ENF:1;
N    __I  uint32_t  RESERVE1:15;
X    volatile const  uint32_t  RESERVE1:15;
N} RTC_AER_T;
N
Ntypedef struct
N{
N    __IO uint32_t  FRACTION:6;
X    volatile uint32_t  FRACTION:6;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  INTEGER:4;
X    volatile uint32_t  INTEGER:4;
N    __I  uint32_t  RESERVE1:20;
X    volatile const  uint32_t  RESERVE1:20;
N} RTC_FCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  SEC1:4;
X    volatile uint32_t  SEC1:4;
N    __IO uint32_t  SEC10:3;
X    volatile uint32_t  SEC10:3;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  MIN1:4;
X    volatile uint32_t  MIN1:4;
N    __IO uint32_t  MIN10:3;
X    volatile uint32_t  MIN10:3;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __IO uint32_t  HR1:4;
X    volatile uint32_t  HR1:4;
N    __IO uint32_t  HR10:2;
X    volatile uint32_t  HR10:2;
N    __I  uint32_t  RESERVE2:10;
X    volatile const  uint32_t  RESERVE2:10;
N} RTC_TLR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DAY1:4;
X    volatile uint32_t  DAY1:4;
N    __IO uint32_t  DAY10:2;
X    volatile uint32_t  DAY10:2;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  MON1:4;
X    volatile uint32_t  MON1:4;
N    __IO uint32_t  MON10:1;
X    volatile uint32_t  MON10:1;
N    __I  uint32_t  RESERVE1:3;
X    volatile const  uint32_t  RESERVE1:3;
N    __IO uint32_t  YEAR1:4;
X    volatile uint32_t  YEAR1:4;
N    __IO uint32_t  YEAR10:4;
X    volatile uint32_t  YEAR10:4;
N    __I  uint32_t  RESERVE2:8;
X    volatile const  uint32_t  RESERVE2:8;
N} RTC_CLR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  HR24:1;
X    volatile uint32_t  HR24:1;
N    __I  uint32_t  RESERVE:31;
X    volatile const  uint32_t  RESERVE:31;
N} RTC_TSSR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DWR:3;
X    volatile uint32_t  DWR:3;
N    __I  uint32_t  RESERVE:29;
X    volatile const  uint32_t  RESERVE:29;
N} RTC_DWR_T;
N
Ntypedef RTC_TLR_T   RTC_TAR_T;
Ntypedef RTC_CLR_T   RTC_CAR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  LIR:1;
X    volatile uint32_t  LIR:1;
N    __I  uint32_t  RESERVE:31;
X    volatile const  uint32_t  RESERVE:31;
N} RTC_LIR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  AIER:1;
X    volatile uint32_t  AIER:1;
N    __IO uint32_t  TIER:1;
X    volatile uint32_t  TIER:1;
N    __I  uint32_t  RESERVE:30;
X    volatile const  uint32_t  RESERVE:30;
N} RTC_RIER_T;
N
N
N
Ntypedef struct
N{
N    __IO uint32_t  AI:1;
X    volatile uint32_t  AI:1;
N    __IO uint32_t  TI:1;
X    volatile uint32_t  TI:1;
N    __I  uint32_t  RESERVE:30;
X    volatile const  uint32_t  RESERVE:30;
N} RTC_RIIR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TTR:3;
X    volatile uint32_t  TTR:3;
N    __IO uint32_t  TWKE:1;
X    volatile uint32_t  TWKE:1;
N    __I  uint32_t  RESERVE:28;
X    volatile const  uint32_t  RESERVE:28;
N} RTC_TTR_T;
N
Ntypedef struct
N{
N    RTC_INIR_T  INIR;
N    RTC_AER_T   AER;
N    RTC_FCR_T   FCR;
N    RTC_TLR_T   TLR;
N    RTC_CLR_T   CLR;
N    RTC_TSSR_T  TSSR;
N    RTC_DWR_T   DWR;
N    RTC_TAR_T   TAR;
N    RTC_CAR_T   CAR;
N    RTC_LIR_T   LIR;
N    RTC_RIER_T  RIER;
N    RTC_RIIR_T  RIIR;
N    RTC_TTR_T   TTR;
N} RTC_T;
N
N
N/*----------------------------- ADC Controller -------------------------------*/
N
Ntypedef struct
N{
N    __IO uint32_t FIFO_IE_LEV:3;
X    volatile uint32_t FIFO_IE_LEV:3;
N    __I  uint32_t RESERVE:28;
X    volatile const  uint32_t RESERVE:28;
N    __IO uint32_t IE:1;
X    volatile uint32_t IE:1;
N} ADC_INT_T;
N
Ntypedef struct
N{
N    __IO uint32_t OSR:4;
X    volatile uint32_t OSR:4;
N    __I  uint32_t RESERVE:12;
X    volatile const  uint32_t RESERVE:12;
N    __IO uint32_t GAIN:4;
X    volatile uint32_t GAIN:4;
N    __I  uint32_t RESERVE1:12;
X    volatile const  uint32_t RESERVE1:12;
N} ADC_DEC_T;
N
Ntypedef struct
N{
N    __IO uint32_t RxDmaEn:1;
X    volatile uint32_t RxDmaEn:1;
N    __I  uint32_t RESERVE:31;
X    volatile const  uint32_t RESERVE:31;
N} ADC_ADPDMA_T;
N
Ntypedef struct
N{
N    __IO uint32_t CMPEN:1;
X    volatile uint32_t CMPEN:1;
N    __IO uint32_t CMPIE:1;
X    volatile uint32_t CMPIE:1;
N    __IO uint32_t CMPCOND:1;
X    volatile uint32_t CMPCOND:1;
N    __I  uint32_t RESERVE:4;
X    volatile const  uint32_t RESERVE:4;
N    __IO uint32_t CMPF:1;
X    volatile uint32_t CMPF:1;
N    __IO uint32_t CMPMATCHCNT:4;
X    volatile uint32_t CMPMATCHCNT:4;
N    __I  uint32_t RESERVE1:4;
X    volatile const  uint32_t RESERVE1:4;
N    __IO uint32_t CMPD:16;
X    volatile uint32_t CMPD:16;
N}  ADC_ADCMPR_T;
N
Ntypedef struct
N{
N    __I  uint32_t           ADCOUT;
X    volatile const  uint32_t           ADCOUT;
N    __IO uint32_t           EN;
X    volatile uint32_t           EN;
N    __IO uint32_t           CLK_DIV;
X    volatile uint32_t           CLK_DIV;
N    ADC_DEC_T               DEC;
N    ADC_INT_T               INT;
N    ADC_ADPDMA_T			ADCPDMA;
N    ADC_ADCMPR_T            ADCMPR[2];
N} SDADC_T;
N
N/*---------------------- Analog Comparator Controller -------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  CMPEN:1;
X    volatile uint32_t  CMPEN:1;
N    __IO uint32_t  CMPIE:1;
X    volatile uint32_t  CMPIE:1;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  CMPCN:1;
X    volatile uint32_t  CMPCN:1;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __I  uint32_t  RESERVE:26;
X    volatile const  uint32_t  RESERVE:26;
N} ACMP_CMPCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  CMPF0:1;
X    volatile uint32_t  CMPF0:1;
N    __IO uint32_t  CMPF1:1;
X    volatile uint32_t  CMPF1:1;
N    __I  uint32_t  CO0:1;
X    volatile const  uint32_t  CO0:1;
N    __I  uint32_t  CO1:1;
X    volatile const  uint32_t  CO1:1;
N    __I  uint32_t  RESERVE:28;
X    volatile const  uint32_t  RESERVE:28;
N} ACMP_CMPSR_T;
N
Ntypedef struct
N{
N    ACMP_CMPCR_T CMPCR[2];
N    ACMP_CMPSR_T CMPSR;
N    __IO uint32_t CMPSEL;
X    volatile uint32_t CMPSEL;
N} ACMP_T;
N
N/*---------------------------- Clock Controller ------------------------------*/
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:1;	   // 0
X    volatile const  uint32_t  RESERVE0:1;	   
N    __IO uint32_t  XTL32K_EN:1;	   // 1
X    volatile uint32_t  XTL32K_EN:1;	   
N    __IO uint32_t  OSC49M_EN:1;	   // 2
X    volatile uint32_t  OSC49M_EN:1;	   
N    __IO uint32_t  OSC10K_EN:1;	   // 3
X    volatile uint32_t  OSC10K_EN:1;	   
N    __I  uint32_t  RESERVE4:5;	   // 4-8
X    volatile const  uint32_t  RESERVE4:5;	   
N    __IO uint32_t  STOP:1;         // 9
X    volatile uint32_t  STOP:1;         
N    __IO uint32_t  STANDBY_PD:1;   // 10
X    volatile uint32_t  STANDBY_PD:1;   
N    __IO uint32_t  DEEP_PD:1;      // 11
X    volatile uint32_t  DEEP_PD:1;      
N    __IO uint32_t  HOLD_IO:1;      // 12
X    volatile uint32_t  HOLD_IO:1;      
N    __IO uint32_t  RELEASE_IO:1;   // 13
X    volatile uint32_t  RELEASE_IO:1;   
N    __I  uint32_t  IO_STATE:1;     // 14
X    volatile const  uint32_t  IO_STATE:1;     
N    __I  uint32_t  RESERVE1:1;     // 15
X    volatile const  uint32_t  RESERVE1:1;     
N    __IO uint32_t  PIN_ENB:1;      // 16
X    volatile uint32_t  PIN_ENB:1;      
N    __IO uint32_t  OSC10K_ENB:1;   // 17
X    volatile uint32_t  OSC10K_ENB:1;   
N    __I  uint32_t  RESERVE2:2;     // 18-19
X    volatile const  uint32_t  RESERVE2:2;     
N    __IO uint32_t  TIMER_SEL:4;    // 20-23
X    volatile uint32_t  TIMER_SEL:4;    
N    __I  uint32_t  PIN_WAKE:1;	   // 24
X    volatile const  uint32_t  PIN_WAKE:1;	   
N    __I  uint32_t  TIMER_WAKE:1;   // 25
X    volatile const  uint32_t  TIMER_WAKE:1;   
N    __I  uint32_t  POI_WAKE:1;	   // 26
X    volatile const  uint32_t  POI_WAKE:1;	   
N    __IO uint32_t  DPD_STATUS_RST:1; // 27
X    volatile uint32_t  DPD_STATUS_RST:1; 
N    __I  uint32_t  TIMER_SEL_RD:4; // 28-31
X    volatile const  uint32_t  TIMER_SEL_RD:4; 
N} SYSCLK_PWRCON_T;
N
Ntypedef struct
N{
N    __IO uint32_t  CPU_EN:1;
X    volatile uint32_t  CPU_EN:1;
N    __IO uint32_t  PDMA_EN:1;
X    volatile uint32_t  PDMA_EN:1;
N    __IO uint32_t  ISP_EN:1;
X    volatile uint32_t  ISP_EN:1;
N    __I  uint32_t  RESERVE1:29;
X    volatile const  uint32_t  RESERVE1:29;
N} SYSCLK_AHBCLK_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  WDG_EN:1;	//0
X    volatile uint32_t  WDG_EN:1;	
N    __I  uint32_t  RESERVE0:4;  //1-4
X    volatile const  uint32_t  RESERVE0:4;  
N    __IO uint32_t  RTC_EN:1;	//5
X    volatile uint32_t  RTC_EN:1;	
N    __IO uint32_t  TMR0_EN:1;	//6
X    volatile uint32_t  TMR0_EN:1;	
N    __IO uint32_t  TMR1_EN:1;	//7
X    volatile uint32_t  TMR1_EN:1;	
N    __IO uint32_t  I2C0_EN:1;	//8
X    volatile uint32_t  I2C0_EN:1;	
N    __I  uint32_t  RESERVE1:3;	//9-11
X    volatile const  uint32_t  RESERVE1:3;	
N    __IO uint32_t  SPI0_EN:1;	//12
X    volatile uint32_t  SPI0_EN:1;	
N    __IO uint32_t  DPWM_EN:1;	//13
X    volatile uint32_t  DPWM_EN:1;	
N    __I  uint32_t  RESERVE2:2;	//14-15
X    volatile const  uint32_t  RESERVE2:2;	
N    __IO uint32_t  UART0_EN:1;	//16
X    volatile uint32_t  UART0_EN:1;	
N    __I  uint32_t  RESERVE3:1;	//17
X    volatile const  uint32_t  RESERVE3:1;	
N    __IO uint32_t  BIQALC_EN:1;	//18
X    volatile uint32_t  BIQALC_EN:1;	
N    __IO uint32_t  CRC_EN:1;	//19
X    volatile uint32_t  CRC_EN:1;	
N    __IO uint32_t  PWM01_EN:1;	//20
X    volatile uint32_t  PWM01_EN:1;	
N    __IO uint32_t  PWM23_EN:1;	//21
X    volatile uint32_t  PWM23_EN:1;	
N    __IO uint32_t  ACMP_EN:1;	//22
X    volatile uint32_t  ACMP_EN:1;	
N    __I  uint32_t  RESERVE5:3;	//23-25
X    volatile const  uint32_t  RESERVE5:3;	
N    __IO uint32_t  SBRAM_EN:1;	//26
X    volatile uint32_t  SBRAM_EN:1;	
N    __I  uint32_t  RESERVE6:1;	//27
X    volatile const  uint32_t  RESERVE6:1;	
N    __IO uint32_t  ADC_EN:1;	//28
X    volatile uint32_t  ADC_EN:1;	
N    __IO uint32_t  I2S_EN:1;	//29
X    volatile uint32_t  I2S_EN:1;	
N    __IO uint32_t  ANA_EN:1;	//30
X    volatile uint32_t  ANA_EN:1;	
N    __IO uint32_t  PWM45_EN:1;	//31
X    volatile uint32_t  PWM45_EN:1;	
N}  SYSCLK_APBCLK_T;
N
Ntypedef struct
N{
N    __IO uint32_t  CPU_EN:1;    //0
X    volatile uint32_t  CPU_EN:1;    
N    __IO uint32_t  PDMA_EN:1;   //1
X    volatile uint32_t  PDMA_EN:1;   
N    __IO uint32_t  ISP_EN:1;    //2
X    volatile uint32_t  ISP_EN:1;    
N    __I  uint32_t  RESERVE0:1;  //3
X    volatile const  uint32_t  RESERVE0:1;  
N    __IO uint32_t  WDG_EN:1;	//4
X    volatile uint32_t  WDG_EN:1;	
N    __IO uint32_t  RTC_EN:1;	//5
X    volatile uint32_t  RTC_EN:1;	
N    __IO uint32_t  TMR0_EN:1;	//6
X    volatile uint32_t  TMR0_EN:1;	
N    __IO uint32_t  TMR1_EN:1;	//7
X    volatile uint32_t  TMR1_EN:1;	
N    __IO uint32_t  I2C0_EN:1;	//8
X    volatile uint32_t  I2C0_EN:1;	
N    __I  uint32_t  RESERVE1:3;	//9-11
X    volatile const  uint32_t  RESERVE1:3;	
N    __IO uint32_t  SPI0_EN:1;	//12
X    volatile uint32_t  SPI0_EN:1;	
N    __IO uint32_t  DPWM_EN:1;	//13
X    volatile uint32_t  DPWM_EN:1;	
N    __I  uint32_t  RESERVE2:2;	//14-15
X    volatile const  uint32_t  RESERVE2:2;	
N    __IO uint32_t  UART0_EN:1;	//16
X    volatile uint32_t  UART0_EN:1;	
N    __I  uint32_t  RESERVE3:1;	//17
X    volatile const  uint32_t  RESERVE3:1;	
N    __IO uint32_t  BIQALC_EN:1;	//18
X    volatile uint32_t  BIQALC_EN:1;	
N    __IO uint32_t  CRC_EN:1;	//19
X    volatile uint32_t  CRC_EN:1;	
N    __IO uint32_t  PWM01_EN:1;	//20
X    volatile uint32_t  PWM01_EN:1;	
N    __IO uint32_t  PWM23_EN:1;	//21
X    volatile uint32_t  PWM23_EN:1;	
N    __IO uint32_t  ACMP_EN:1;	//22
X    volatile uint32_t  ACMP_EN:1;	
N    __I  uint32_t  RESERVE5:3;	//23-25
X    volatile const  uint32_t  RESERVE5:3;	
N    __IO uint32_t  SBRAM_EN:1;	//26
X    volatile uint32_t  SBRAM_EN:1;	
N    __I  uint32_t  RESERVE6:1;	//27
X    volatile const  uint32_t  RESERVE6:1;	
N    __IO uint32_t  ADC_EN:1;	//28
X    volatile uint32_t  ADC_EN:1;	
N    __IO uint32_t  I2S_EN:1;	//29
X    volatile uint32_t  I2S_EN:1;	
N    __IO uint32_t  ANA_EN:1;	//30
X    volatile uint32_t  ANA_EN:1;	
N    __IO uint32_t  PWM45_EN:1;	//31
X    volatile uint32_t  PWM45_EN:1;	
N}  SYSCLK_CLKSLEEP_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DPD_STATE_WR:8;
X    volatile uint32_t  DPD_STATE_WR:8;
N    __I  uint32_t  DPD_STATE_RD:8;
X    volatile const  uint32_t  DPD_STATE_RD:8;
N    __I  uint32_t  RESERVE:16;
X    volatile const  uint32_t  RESERVE:16;
N} SYSCLK_DPDSTATE_T;
N
Ntypedef struct
N{
N    __IO uint32_t  HCLK_S:3;
X    volatile uint32_t  HCLK_S:3;
N    __IO uint32_t  STCLK_S:3;
X    volatile uint32_t  STCLK_S:3;
N    __IO uint32_t  OSCFSel:2;
X    volatile uint32_t  OSCFSel:2;
N    __I  uint32_t  RESERVE:24;
X    volatile const  uint32_t  RESERVE:24;
N} SYSCLK_CLKSEL0_T;
N
Ntypedef struct
N{
N    __IO uint32_t  WDG_S:2;
X    volatile uint32_t  WDG_S:2;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  DPWM_S:1;
X    volatile uint32_t  DPWM_S:1;
N    __I  uint32_t  RESERVE1:3;
X    volatile const  uint32_t  RESERVE1:3;
N    __IO uint32_t  TMR0_S:3;
X    volatile uint32_t  TMR0_S:3;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  TMR1_S:3;
X    volatile uint32_t  TMR1_S:3;
N    __I  uint32_t  RESERVE3:13;
X    volatile const  uint32_t  RESERVE3:13;
N    __IO uint32_t  PWM01_S:2;
X    volatile uint32_t  PWM01_S:2;
N    __IO uint32_t  PWM23_S:2;
X    volatile uint32_t  PWM23_S:2;
N} SYSCLK_CLKSEL1_T;
N
Ntypedef struct
N{
N    __IO uint32_t  I2S_S:2;
X    volatile uint32_t  I2S_S:2;
N    __I  uint32_t  RESERVE1:2;
X    volatile const  uint32_t  RESERVE1:2;
N    __IO uint32_t  PWM45_S:2;
X    volatile uint32_t  PWM45_S:2;
N    __I  uint32_t  RESERVE:26;
X    volatile const  uint32_t  RESERVE:26;
N} SYSCLK_CLKSEL2_T;
N
Ntypedef struct
N{
N    __IO uint32_t  HCLK_N:4;
X    volatile uint32_t  HCLK_N:4;
N    __I  uint32_t  RESERVE0:4;
X    volatile const  uint32_t  RESERVE0:4;
N    __IO uint32_t  UART_N:4;
X    volatile uint32_t  UART_N:4;
N    __I  uint32_t  RESERVE1:4;
X    volatile const  uint32_t  RESERVE1:4;
N    __IO uint32_t  ADC_N:8;
X    volatile uint32_t  ADC_N:8;
N    __I  uint32_t  RESERVE:8;
X    volatile const  uint32_t  RESERVE:8;
N} SYSCLK_CLKDIV_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  FSEL:4;
X    volatile uint32_t  FSEL:4;
N    __IO uint32_t  FDIV_EN:1;
X    volatile uint32_t  FDIV_EN:1;
N    __I  uint32_t  RESERVE:27;
X    volatile const  uint32_t  RESERVE:27;
N} SYSCLK_FRQDIV_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DS_FLAG:1;
X    volatile uint32_t  DS_FLAG:1;
N    __IO uint32_t  STOP_FLAG:1;
X    volatile uint32_t  STOP_FLAG:1;
N    __IO uint32_t  PD_FLAG:1;
X    volatile uint32_t  PD_FLAG:1;
N    __I  uint32_t  RESERVE:29;
X    volatile const  uint32_t  RESERVE:29;
N} SYSCLK_PFLAGCON_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DISABLE_PD:1;
X    volatile uint32_t  DISABLE_PD:1;
N    __I  uint32_t  RESERVE1:5;
X    volatile const  uint32_t  RESERVE1:5;
N    __I  uint32_t  ICE_CLK:1;
X    volatile const  uint32_t  ICE_CLK:1;
N    __I  uint32_t  ICE_DAT:1;
X    volatile const  uint32_t  ICE_DAT:1;
N    __I  uint32_t  RESERVE2:24;
X    volatile const  uint32_t  RESERVE2:24;
N} SYSCLK_DBGPD_T;
N
Ntypedef struct
N{
N    SYSCLK_PWRCON_T    PWRCON;
N    SYSCLK_AHBCLK_T    AHBCLK;
N    SYSCLK_APBCLK_T    APBCLK;
N    SYSCLK_DPDSTATE_T  DPDSTATE;
N    SYSCLK_CLKSEL0_T   CLKSEL0;
N    SYSCLK_CLKSEL1_T   CLKSEL1;
N    SYSCLK_CLKDIV_T    CLKDIV;
N    SYSCLK_CLKSEL2_T   CLKSEL2;
N    SYSCLK_CLKSLEEP_T  CLKSLEEP;
N    SYSCLK_PFLAGCON_T  PFLAGCON;
N    SYSCLK_DBGPD_T     DBGPD;
N} SYSCLK_T;
N
N
N/*---------------------------- Global Controller -----------------------------*/
Ntypedef __I uint32_t GCR_PDID_T;
Xtypedef volatile const uint32_t GCR_PDID_T;
N//------------------------------------------------------
N// This register tells what triggered the last reset
N// Bit0 - POR reset
N// Bit1 - PAD reset
N// Bit2 - WDT reset
N//
N
N// Access via SYS->RSTSRC
Ntypedef struct
N{
N    __IO uint32_t  RSTS_POR:1;
X    volatile uint32_t  RSTS_POR:1;
N    __IO uint32_t  RSTS_PAD:1;
X    volatile uint32_t  RSTS_PAD:1;
N    __IO uint32_t  RSTS_WDG:1;
X    volatile uint32_t  RSTS_WDG:1;
N    __I  uint32_t  RESERVE1:2;
X    volatile const  uint32_t  RESERVE1:2;
N    __IO uint32_t  RSTS_SYS:1;
X    volatile uint32_t  RSTS_SYS:1;
N    __IO uint32_t  RSTS_PMU:1;
X    volatile uint32_t  RSTS_PMU:1;
N    __IO uint32_t  RSTS_CPU:1;
X    volatile uint32_t  RSTS_CPU:1;
N    __IO uint32_t  RSTS_PIN:1;
X    volatile uint32_t  RSTS_PIN:1;
N    __IO uint32_t  RSTS_TIM:1;
X    volatile uint32_t  RSTS_TIM:1;
N    __IO uint32_t  RSTS_POI:1;
X    volatile uint32_t  RSTS_POI:1;
N    __I  uint32_t  RESERVE:21;
X    volatile const  uint32_t  RESERVE:21;
N} GCR_RSTSRC_T;
N// -----------------------------
N// This register, when written 1, triggers reset
N// of the corresponding block
N// Bit 0 - chip reset
N// BIt 1 - core reset (resets the M0 core only)
N// Bit 2 - resets all the PDMA
N//
N
Ntypedef struct
N{
N    __IO uint32_t  CHIP_RST:1;
X    volatile uint32_t  CHIP_RST:1;
N    __IO uint32_t  CPU_RST:1;
X    volatile uint32_t  CPU_RST:1;
N    __IO uint32_t  PDMA_RST:1;
X    volatile uint32_t  PDMA_RST:1;
N    __I  uint32_t  RESERVE:29;
X    volatile const  uint32_t  RESERVE:29;
N} GCR_IPRSTC1_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:6;
X    volatile const  uint32_t  RESERVE0:6;
N    __IO uint32_t  TMR0_RST:1; //6
X    volatile uint32_t  TMR0_RST:1; 
N    __IO uint32_t  TMR1_RST:1; //7
X    volatile uint32_t  TMR1_RST:1; 
N    __IO uint32_t  I2C0_RST:1; //8
X    volatile uint32_t  I2C0_RST:1; 
N    __I  uint32_t  RESERVE1:3; //9-11
X    volatile const  uint32_t  RESERVE1:3; 
N    __IO uint32_t  SPI0_RST:1; //12
X    volatile uint32_t  SPI0_RST:1; 
N    __IO uint32_t  DPWM_RST:1; //13
X    volatile uint32_t  DPWM_RST:1; 
N    __I  uint32_t  RESERVE2:2; //14-15
X    volatile const  uint32_t  RESERVE2:2; 
N    __IO uint32_t  UART0_RST:1;//16
X    volatile uint32_t  UART0_RST:1;
N    __I  uint32_t  RESERVE3:1; //17
X    volatile const  uint32_t  RESERVE3:1; 
N    __IO uint32_t  BIQ_RST:1;  //18
X    volatile uint32_t  BIQ_RST:1;  
N    __IO uint32_t  CRC_RST:1;  //19
X    volatile uint32_t  CRC_RST:1;  
N    __IO uint32_t  PWM03_RST:1;//20
X    volatile uint32_t  PWM03_RST:1;
N    __IO uint32_t  PWM47_RST:1;//21
X    volatile uint32_t  PWM47_RST:1;
N    __IO uint32_t  ACMP_RST:1; //22
X    volatile uint32_t  ACMP_RST:1; 
N    __I  uint32_t  RESERVE5:5; //23-27
X    volatile const  uint32_t  RESERVE5:5; 
N    __IO uint32_t  ADC_RST:1;  //28
X    volatile uint32_t  ADC_RST:1;  
N    __IO uint32_t  I2S_RST:1;  //29
X    volatile uint32_t  I2S_RST:1;  
N    __IO uint32_t  ANA_RST:1;  //30
X    volatile uint32_t  ANA_RST:1;  
N    __I  uint32_t  RESERVE6:1; //31
X    volatile const  uint32_t  RESERVE6:1; 
N} GCR_IPRSTC2_T;
N
N
Ntypedef struct
N{
N    __I  uint32_t RESERVE:16;
X    volatile const  uint32_t RESERVE:16;
N    __IO uint32_t SCHMITT:16;
X    volatile uint32_t SCHMITT:16;
N} GCR_GPA_INP_T;
N
Ntypedef struct
N{
N    __IO uint32_t GPA0:2;
X    volatile uint32_t GPA0:2;
N    __IO uint32_t GPA1:2;
X    volatile uint32_t GPA1:2;
N    __IO uint32_t GPA2:2;
X    volatile uint32_t GPA2:2;
N    __IO uint32_t GPA3:2;
X    volatile uint32_t GPA3:2;
N    __IO uint32_t GPA4:2;
X    volatile uint32_t GPA4:2;
N    __IO uint32_t GPA5:2;
X    volatile uint32_t GPA5:2;
N    __IO uint32_t GPA6:2;
X    volatile uint32_t GPA6:2;
N    __IO uint32_t GPA7:2;
X    volatile uint32_t GPA7:2;
N    __IO uint32_t GPA8:2;
X    volatile uint32_t GPA8:2;
N    __IO uint32_t GPA9:2;
X    volatile uint32_t GPA9:2;
N    __IO uint32_t GPA10:2;
X    volatile uint32_t GPA10:2;
N    __IO uint32_t GPA11:2;
X    volatile uint32_t GPA11:2;
N    __IO uint32_t GPA12:2;
X    volatile uint32_t GPA12:2;
N    __IO uint32_t GPA13:2;
X    volatile uint32_t GPA13:2;
N    __IO uint32_t GPA14:2;
X    volatile uint32_t GPA14:2;
N    __IO uint32_t GPA15:2;
X    volatile uint32_t GPA15:2;
N} GCR_GPA_ALT_T;
N
Ntypedef struct
N{
N    __IO uint32_t GPB0:2;
X    volatile uint32_t GPB0:2;
N    __IO uint32_t GPB1:2;
X    volatile uint32_t GPB1:2;
N    __IO uint32_t GPB2:2;
X    volatile uint32_t GPB2:2;
N    __IO uint32_t GPB3:2;
X    volatile uint32_t GPB3:2;
N    __IO uint32_t GPB4:2;
X    volatile uint32_t GPB4:2;
N    __IO uint32_t GPB5:2;
X    volatile uint32_t GPB5:2;
N    __IO uint32_t GPB6:2;
X    volatile uint32_t GPB6:2;
N    __IO uint32_t GPB7:2;
X    volatile uint32_t GPB7:2;
N    __IO uint32_t GPB8:2;
X    volatile uint32_t GPB8:2;
N    __IO uint32_t GPB9:2;
X    volatile uint32_t GPB9:2;
N    __IO uint32_t GPB10:2;
X    volatile uint32_t GPB10:2;
N    __IO uint32_t GPB11:2;
X    volatile uint32_t GPB11:2;
N    __IO uint32_t GPB12:2;
X    volatile uint32_t GPB12:2;
N    __IO uint32_t GPB13:2;
X    volatile uint32_t GPB13:2;
N    __IO uint32_t GPB14:2;
X    volatile uint32_t GPB14:2;
N    __IO uint32_t GPB15:2;
X    volatile uint32_t GPB15:2;
N} GCR_GPB_ALT_T;
N
N
N
Ntypedef struct
N{
N    __I  uint32_t RESERVE:16;
X    volatile const  uint32_t RESERVE:16;
N    __IO uint32_t SCHMITT:16;
X    volatile uint32_t SCHMITT:16;
N} GCR_GPB_INP_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  WAKE_DOUT:1;
X    volatile uint32_t  WAKE_DOUT:1;
N    __IO uint32_t  WAKE_OENB:1;
X    volatile uint32_t  WAKE_OENB:1;
N    __IO uint32_t  WAKE_TRI:1;
X    volatile uint32_t  WAKE_TRI:1;
N    __I  uint32_t  WAKE_DIN:1;
X    volatile const  uint32_t  WAKE_DIN:1;
N    __I  uint32_t  RESERVE:28;
X    volatile const  uint32_t  RESERVE:28;
N} GCR_WAKECR_T;
N
Ntypedef __IO uint32_t GCR_REGLOCK_T;
Xtypedef volatile uint32_t GCR_REGLOCK_T;
N
Ntypedef struct
N{
N    __IO uint16_t  TRIM:8;
X    volatile uint16_t  TRIM:8;
N    __IO uint16_t  RANGE:1;
X    volatile uint16_t  RANGE:1;
N    __I  uint16_t  RESERVE:7;
X    volatile const  uint16_t  RESERVE:7;
N}GCR_OSCTRIM_T;
N
Ntypedef struct
N{
N// New trim with TC ADJ
N    __IO uint32_t  TRIM:8;     // 7:0
X    volatile uint32_t  TRIM:8;     
N    __IO uint32_t  RANGE:1;    // 8
X    volatile uint32_t  RANGE:1;    
N    __IO uint32_t  FINE:4;     // 12:9
X    volatile uint32_t  FINE:4;     
N    __I  uint32_t  RESERVE0:3; // 15:13
X    volatile const  uint32_t  RESERVE0:3; 
N    __IO uint32_t  TC:9;       // 24:16
X    volatile uint32_t  TC:9;       
N    __I  uint32_t  RESERVE:7; // 31:25
X    volatile const  uint32_t  RESERVE:7; 
N}GCR_OSC_TRIM_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TRIM:9;
X    volatile uint32_t  TRIM:9;
N    __I  uint32_t  RESERVE1:7;
X    volatile const  uint32_t  RESERVE1:7;
N    __IO uint32_t  TM_REG:5;
X    volatile uint32_t  TM_REG:5;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  IBGEN:2;
X    volatile uint32_t  IBGEN:2;
N    __I  uint32_t  RESERVE3:7;
X    volatile const  uint32_t  RESERVE3:7;
N    __IO uint32_t  TRIM_CLK:1;
X    volatile uint32_t  TRIM_CLK:1;
N}GCR_OSC10K_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  INTSRC:3;
X    volatile uint32_t  INTSRC:3;
N    __I  uint32_t  RESERVE:29;
X    volatile const  uint32_t  RESERVE:29;
N} GCR_INTSRC_T;
N
Ntypedef struct
N{
N    __IO uint32_t  NMISEL:5;
X    volatile uint32_t  NMISEL:5;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  INT_TEST:1;
X    volatile uint32_t  INT_TEST:1;
N    __I  uint32_t  RESERVE1:24;
X    volatile const  uint32_t  RESERVE1:24;
N} GCR_NMISEL_T;
N
N
Ntypedef __IO uint32_t GCR_MCUIRQ_T;
Xtypedef volatile uint32_t GCR_MCUIRQ_T;
N
Ntypedef struct
N{
N    GCR_PDID_T      PDID;
N    GCR_RSTSRC_T    RSTSRC;
N    GCR_IPRSTC1_T   IPRSTC1;
N    GCR_IPRSTC2_T   IPRSTC2;
N    uint32_t        RESERVE1[8];
N    GCR_GPA_INP_T   GPA_INP;
N    GCR_GPB_INP_T   GPB_INP;
N    GCR_GPA_ALT_T   GPA_ALT;
N    GCR_GPB_ALT_T   GPB_ALT;
N    uint32_t        RESERVE3[5];
N    GCR_WAKECR_T    WAKECR;
N    uint32_t        RESERVE4[42];
N    GCR_REGLOCK_T   REGLOCK;        // 0x100
N    uint32_t        RESERVE5[3];    // 0x104-10C
N    GCR_OSCTRIM_T   OSCTRIM[2];     // 0x110  (half word each)
N    GCR_OSC10K_T    OSC10K;         // 0x114
N    GCR_OSC_TRIM_T  OSC_TRIM[3];    // 0x118-0x120
N}  GCR_T;
N
N
Ntypedef struct
N{
N    GCR_INTSRC_T    INTSRC[32];
N    GCR_NMISEL_T    NMISEL;
N    GCR_MCUIRQ_T    MCUIRQ;
N} GCR_INT_T;
N
N/*-------------------------- FLASH Memory Controller -------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  ISPEN:1;
X    volatile uint32_t  ISPEN:1;
N    __IO uint32_t  BS:1;
X    volatile uint32_t  BS:1;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  CFGUEN:1;
X    volatile uint32_t  CFGUEN:1;
N    __IO uint32_t  LDUEN:1;
X    volatile uint32_t  LDUEN:1;
N    __IO uint32_t  ISPFF:1;
X    volatile uint32_t  ISPFF:1;
N    __IO uint32_t  SWRST:1;
X    volatile uint32_t  SWRST:1;
N    __IO uint32_t  PT:3;
X    volatile uint32_t  PT:3;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __IO uint32_t  ET:3;
X    volatile uint32_t  ET:3;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  WAIT_CFG:3;
X    volatile uint32_t  WAIT_CFG:3;
N    __IO uint32_t  MULT2X:1;
X    volatile uint32_t  MULT2X:1;
N    __I  uint32_t  RESERVE3:1;
X    volatile const  uint32_t  RESERVE3:1;
N    __IO uint32_t  CACHE_DIS:1;
X    volatile uint32_t  CACHE_DIS:1;
N    __I  uint32_t  RESERVE4:10;
X    volatile const  uint32_t  RESERVE4:10;
N
N} FMC_ISPCON_T;
N
Ntypedef __IO uint32_t FMC_ISPADR_T;
Xtypedef volatile uint32_t FMC_ISPADR_T;
Ntypedef __IO uint32_t FMC_ISPDAT_T;
Xtypedef volatile uint32_t FMC_ISPDAT_T;
Ntypedef __IO uint32_t FMC_ISPCMD_T;
Xtypedef volatile uint32_t FMC_ISPCMD_T;
Ntypedef __IO uint32_t FMC_ISPTRG_T;
Xtypedef volatile uint32_t FMC_ISPTRG_T;
Ntypedef __I uint32_t  FMC_DFBADR_T;
Xtypedef volatile const uint32_t  FMC_DFBADR_T;
N
N
N
N
N
Ntypedef struct
N{
N    FMC_ISPCON_T    ISPCON;
N    FMC_ISPADR_T    ISPADR;
N    FMC_ISPDAT_T    ISPDAT;
N    FMC_ISPCMD_T    ISPCMD;
N    FMC_ISPTRG_T    ISPTRG;
N    FMC_DFBADR_T    DFBADR;
N	__I uint32_t	RESERVED[3];
X	volatile const uint32_t	RESERVED[3];
N	__IO uint32_t	TRIM_RD;
X	volatile uint32_t	TRIM_RD;
N} FMC_T;
N
N
N
N
N/*------------------------------ PDMA Controller -----------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  PDMACEN:1;
X    volatile uint32_t  PDMACEN:1;
N    __IO uint32_t  SW_RST:1;
X    volatile uint32_t  SW_RST:1;
N    __IO uint32_t  MODE_SEL:2;
X    volatile uint32_t  MODE_SEL:2;
N    __IO uint32_t  SAD_SEL:2;
X    volatile uint32_t  SAD_SEL:2;
N    __IO uint32_t  DAD_SEL:2;
X    volatile uint32_t  DAD_SEL:2;
N    __I  uint32_t  RESERVE0:4;
X    volatile const  uint32_t  RESERVE0:4;
N    __IO uint32_t  WRA_INT_SEL:4;
X    volatile uint32_t  WRA_INT_SEL:4;
N    __I  uint32_t  RESERVE1:3;
X    volatile const  uint32_t  RESERVE1:3;
N    __IO uint32_t  APB_TWS:2;
X    volatile uint32_t  APB_TWS:2;
N    __I  uint32_t  RESERVE2:2;
X    volatile const  uint32_t  RESERVE2:2;
N    __IO uint32_t  TRIG_EN:1;
X    volatile uint32_t  TRIG_EN:1;
N    __I  uint32_t  RESERVE3:8;
X    volatile const  uint32_t  RESERVE3:8;
N} PDMA_CSR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  CBCR:24;
X    volatile uint32_t  CBCR:24;
N    __I  uint32_t  RESERVE:8;
X    volatile const  uint32_t  RESERVE:8;
N} PDMA_CBCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TABORT_IE:1;
X    volatile uint32_t  TABORT_IE:1;
N    __IO uint32_t  BLKD_IE:1;
X    volatile uint32_t  BLKD_IE:1;
N    __IO uint32_t  WAR_IE:1;
X    volatile uint32_t  WAR_IE:1;
N    __I  uint32_t  RESERVE:29;
X    volatile const  uint32_t  RESERVE:29;
N} PDMA_IER_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TABORT_IF:1;
X    volatile uint32_t  TABORT_IF:1;
N    __IO uint32_t  BLKD_IF:1;
X    volatile uint32_t  BLKD_IF:1;
N    __I  uint32_t  RESERVE:6;
X    volatile const  uint32_t  RESERVE:6;
N    __IO uint32_t  WAR_IF:4;
X    volatile uint32_t  WAR_IF:4;
N    __I  uint32_t  RESERVE1:3;
X    volatile const  uint32_t  RESERVE1:3;
N    __IO uint32_t  BUSY:1;
X    volatile uint32_t  BUSY:1;
N    __I  uint32_t  RESERVE2:15;
X    volatile const  uint32_t  RESERVE2:15;
N    __IO uint32_t  INTR:1;
X    volatile uint32_t  INTR:1;
N} PDMA_ISR_T;
N
Ntypedef struct
N{
N    __IO int8_t    SPIR;
X    volatile int8_t    SPIR;
N    __I  uint32_t  RESERVE:24;
X    volatile const  uint32_t  RESERVE:24;
N} PDMA_SPIR_T;
N
Ntypedef struct
N{
N    __IO int16_t   CSPIR;
X    volatile int16_t   CSPIR;
N    __I  uint32_t  RESERVE:16;
X    volatile const  uint32_t  RESERVE:16;
N} PDMA_CSPIR_T;
N
Ntypedef struct
N{
N    __IO  uint32_t  	PDMA_RST:1;
X    volatile  uint32_t  	PDMA_RST:1;
N    __I   uint32_t  	RESERVED0:7;
X    volatile const   uint32_t  	RESERVED0:7;
N	__IO  uint32_t  	PDMA0_HCLK_EN:1;
X	volatile  uint32_t  	PDMA0_HCLK_EN:1;
N	__IO  uint32_t  	PDMA1_HCLK_EN:1;
X	volatile  uint32_t  	PDMA1_HCLK_EN:1;
N	__IO  uint32_t  	PDMA2_HCLK_EN:1;
X	volatile  uint32_t  	PDMA2_HCLK_EN:1;
N	__IO  uint32_t  	PDMA3_HCLK_EN:1;
X	volatile  uint32_t  	PDMA3_HCLK_EN:1;
N    __I   uint32_t  	RESERVED1:12;
X    volatile const   uint32_t  	RESERVED1:12;
N	__IO  uint32_t  	CRC_CLK_EN:1;
X	volatile  uint32_t  	CRC_CLK_EN:1;
N    __I   uint32_t  	RESERVED2:7;
X    volatile const   uint32_t  	RESERVED2:7;
N} PDMA_GCR_GCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t       SPI0_RXSEL:4;
X    volatile uint32_t       SPI0_RXSEL:4;
N    __IO uint32_t       SPI0_TXSEL:4;
X    volatile uint32_t       SPI0_TXSEL:4;
N    __IO uint32_t       ADC_RXSEL:4;
X    volatile uint32_t       ADC_RXSEL:4;
N    __IO uint32_t       DPWM_TXSEL:4;
X    volatile uint32_t       DPWM_TXSEL:4;
N    __IO uint32_t       UART0_RXSEL:4;
X    volatile uint32_t       UART0_RXSEL:4;
N    __IO uint32_t       UART0_TXSEL:4;
X    volatile uint32_t       UART0_TXSEL:4;
N    __IO uint32_t       I2S_RXSEL:4;
X    volatile uint32_t       I2S_RXSEL:4;
N    __IO uint32_t       I2S_TXSEL:4;
X    volatile uint32_t       I2S_TXSEL:4;
N} PDMA_GCR_PDSSR_T;
N
N//typedef struct
N//{
N//	__I  uint32_t       PDMA0_GCRISR:1;
N//	__I  uint32_t       PDMA1_GCRISR:1;
N//	__I  uint32_t       PDMA2_GCRISR:1;
N//	__I  uint32_t       PDMA3_GCRISR:1;
N//	__I  uint32_t       RESERVED:28;
N//} PDMA_GCRISR_T;
Ntypedef __IO uint32_t PDMA_GCRISR_T;
Xtypedef volatile uint32_t PDMA_GCRISR_T;
N
Ntypedef struct
N{
N    PDMA_CSR_T          CSR;                   // 0x00
N    __IO uint32_t       SAR;                   // 0x04
X    volatile uint32_t       SAR;                   
N    __IO uint32_t       DAR;                   // 0x08
X    volatile uint32_t       DAR;                   
N    __IO uint32_t       BCR;                   // 0x0C
X    volatile uint32_t       BCR;                   
N    __I  uint32_t       POINT;                 // 0x10
X    volatile const  uint32_t       POINT;                 
N    __I  uint32_t       CSAR;                  // 0x14
X    volatile const  uint32_t       CSAR;                  
N    __I  uint32_t       CDAR;                  // 0x18
X    volatile const  uint32_t       CDAR;                  
N    PDMA_CBCR_T         CBCR;                  // 0x1C
N    PDMA_IER_T          IER;                   // 0x20
N    PDMA_ISR_T          ISR;                   // 0x24
N    __I  uint32_t       RESERVED28[3];         // 0x28 - 0x30
X    volatile const  uint32_t       RESERVED28[3];         
N    PDMA_SPIR_T         SPIR;                  // 0x34
N    PDMA_CSPIR_T        CSPIR;                 // 0x38
N    __I  uint32_t       RESERVED0[49];
X    volatile const  uint32_t       RESERVED0[49];
N} PDMA_T;  // 64 Words
N
Ntypedef struct
N{
N    PDMA_GCR_GCR_T       GCR;
N    PDMA_GCR_PDSSR_T     PDSSR;
N    __I  uint32_t        RESERVE;
X    volatile const  uint32_t        RESERVE;
N    PDMA_GCRISR_T        GCRISR;
N} PDMA_GCR_T;
N
Ntypedef struct {
N    PDMA_T              channel[4];
N    __I  uint32_t       RESERVE[704];
X    volatile const  uint32_t       RESERVE[704];
N    PDMA_GCR_GCR_T      GCR;
N    PDMA_GCR_PDSSR_T    PDSSR;
N    __I  uint32_t       RESERVED;
X    volatile const  uint32_t       RESERVED;
N    PDMA_GCRISR_T       GCRIS;
N} PDMA_PERIPH_T;
N
N
N/*------------------------------ CRC DMA Controller -----------------------------*/
Ntypedef struct
N{
N    __IO  uint32_t  	CRCCEN:1;
X    volatile  uint32_t  	CRCCEN:1;
N    __IO  uint32_t  	CRC_RST:1;
X    volatile  uint32_t  	CRC_RST:1;
N	__I   uint32_t  	RESERVE:21;
X	volatile const   uint32_t  	RESERVE:21;
N	__IO  uint32_t  	TRIG_EN:1;
X	volatile  uint32_t  	TRIG_EN:1;
N	__IO  uint32_t  	WDATA_RVS:1;
X	volatile  uint32_t  	WDATA_RVS:1;
N	__IO  uint32_t  	CHECKSUM_RVS:1;
X	volatile  uint32_t  	CHECKSUM_RVS:1;
N	__IO  uint32_t  	WDATA_COM:1;
X	volatile  uint32_t  	WDATA_COM:1;
N    __IO  uint32_t  	CHECKSUM_COM:1;
X    volatile  uint32_t  	CHECKSUM_COM:1;
N    __IO  uint32_t		CPU_WDLEN:2;
X    volatile  uint32_t		CPU_WDLEN:2;
N    __IO  uint32_t 		CRC_MODE:2;
X    volatile  uint32_t 		CRC_MODE:2;
N} PDMACRC_CTL_T;
N
Ntypedef __IO uint32_t   PDMACRC_DMASAR_T;
Xtypedef volatile uint32_t   PDMACRC_DMASAR_T;
N
Ntypedef struct
N{
N    __IO  uint32_t  	CRC_DMABCR:16;
X    volatile  uint32_t  	CRC_DMABCR:16;
N	__I   uint32_t  	RESERVE:16;
X	volatile const   uint32_t  	RESERVE:16;
N} PDMACRC_DMABCR_T;
N
Ntypedef __I uint32_t    PDMACRC_DMACSAR_T;
Xtypedef volatile const uint32_t    PDMACRC_DMACSAR_T;
N
Ntypedef struct
N{
N    __I   uint32_t  	CRC_DMACBCR:16;
X    volatile const   uint32_t  	CRC_DMACBCR:16;
N	__I   uint32_t  	RESERVE:16;
X	volatile const   uint32_t  	RESERVE:16;
N} PDMACRC_DMACBCR_T;
N
Ntypedef struct
N{
N    __IO  uint32_t  	TABORT_IE:1;
X    volatile  uint32_t  	TABORT_IE:1;
N    __IO  uint32_t  	BLKD_IE:1;
X    volatile  uint32_t  	BLKD_IE:1;
N	__I   uint32_t  	RESERVE:30;
X	volatile const   uint32_t  	RESERVE:30;
N} PDMACRC_DMAIER_T;
N
Ntypedef struct
N{
N    __IO  uint32_t  	TABORT_IF:1;
X    volatile  uint32_t  	TABORT_IF:1;
N    __IO  uint32_t  	BLKD_IF:1;
X    volatile  uint32_t  	BLKD_IF:1;
N	__I   uint32_t  	RESERVE:30;
X	volatile const   uint32_t  	RESERVE:30;
N} PDMACRC_DMAISR_T;
N
Ntypedef __IO uint32_t   PDMACRC_WDATA_T;
Xtypedef volatile uint32_t   PDMACRC_WDATA_T;
N
Ntypedef __IO uint32_t   PDMACRC_SEED_T;
Xtypedef volatile uint32_t   PDMACRC_SEED_T;
N
Ntypedef __I  uint32_t   PDMACRC_CHECKSUM_T;
Xtypedef volatile const  uint32_t   PDMACRC_CHECKSUM_T;
N
Ntypedef struct
N{
N    PDMACRC_CTL_T       CTL;                   // 0x00
N    PDMACRC_DMASAR_T	DMASAR;                // 0x04
N    __I  uint32_t       RESERVED0[1];          // 0x08
X    volatile const  uint32_t       RESERVED0[1];          
N    PDMACRC_DMABCR_T    DMABCR;                // 0x0C
N    __I  uint32_t       RESERVED1[1];          // 0x10
X    volatile const  uint32_t       RESERVED1[1];          
N    PDMACRC_DMACSAR_T   DMACSAR;               // 0x14
N    __I  uint32_t       RESERVED2[1];          // 0x18
X    volatile const  uint32_t       RESERVED2[1];          
N    PDMACRC_DMACBCR_T   DMACBCR;               // 0x1C
N    PDMACRC_DMAIER_T    DMAIER;                // 0x20
N    PDMACRC_DMAISR_T    DMAISR;                // 0x24
N    __I  uint32_t       RESERVED3[22];         // 0x28 - 0x7C
X    volatile const  uint32_t       RESERVED3[22];         
N    PDMACRC_WDATA_T     WDATA;                 // 0x80
N    PDMACRC_SEED_T      SEED;                  // 0x84
N    PDMACRC_CHECKSUM_T  CHECKSUM;              // 0x88
N} PDMACRC_T;
N
N
N/*----------------------------- PWM Controller -------------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  CP01:8;
X    volatile uint32_t  CP01:8;
N    __IO uint32_t  CP23:8;
X    volatile uint32_t  CP23:8;
N    __IO uint32_t  DZI01:8;
X    volatile uint32_t  DZI01:8;
N    __IO uint32_t  DZI23:8;
X    volatile uint32_t  DZI23:8;
N} PWM_PPR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  CSR0:3;
X    volatile uint32_t  CSR0:3;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  CSR1:3;
X    volatile uint32_t  CSR1:3;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __IO uint32_t  CSR2:3;
X    volatile uint32_t  CSR2:3;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  CSR3:3;
X    volatile uint32_t  CSR3:3;
N    __I  uint32_t  RESERVE3:17;
X    volatile const  uint32_t  RESERVE3:17;
N} PWM_CSR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  CH0EN:1;
X    volatile uint32_t  CH0EN:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  CH0INV:1;
X    volatile uint32_t  CH0INV:1;
N    __IO uint32_t  CH0MOD:1;
X    volatile uint32_t  CH0MOD:1;
N    __IO uint32_t  DZEN01:1;
X    volatile uint32_t  DZEN01:1;
N    __IO uint32_t  DZEN23:1;
X    volatile uint32_t  DZEN23:1;
N    __I  uint32_t  RESERVE1:2;
X    volatile const  uint32_t  RESERVE1:2;
N    __IO uint32_t  CH1EN:1;
X    volatile uint32_t  CH1EN:1;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  CH1INV:1;
X    volatile uint32_t  CH1INV:1;
N    __IO uint32_t  CH1MOD:1;
X    volatile uint32_t  CH1MOD:1;
N    __I  uint32_t  RESERVE3:4;
X    volatile const  uint32_t  RESERVE3:4;
N    __IO uint32_t  CH2EN:1;
X    volatile uint32_t  CH2EN:1;
N    __I  uint32_t  RESERVE4:1;
X    volatile const  uint32_t  RESERVE4:1;
N    __IO uint32_t  CH2INV:1;
X    volatile uint32_t  CH2INV:1;
N    __IO uint32_t  CH2MOD:1;
X    volatile uint32_t  CH2MOD:1;
N    __I  uint32_t  RESERVE5:4;
X    volatile const  uint32_t  RESERVE5:4;
N    __IO uint32_t  CH3EN:1;
X    volatile uint32_t  CH3EN:1;
N    __I  uint32_t  RESERVE6:1;
X    volatile const  uint32_t  RESERVE6:1;
N    __IO uint32_t  CH3INV:1;
X    volatile uint32_t  CH3INV:1;
N    __IO uint32_t  CH3MOD:1;
X    volatile uint32_t  CH3MOD:1;
N    __I  uint32_t  RESERVE7:4;
X    volatile const  uint32_t  RESERVE7:4;
N} PWM_PCR_T;
N
Ntypedef __IO uint32_t PWM_CNR_T;
Xtypedef volatile uint32_t PWM_CNR_T;
N
Ntypedef __IO uint32_t PWM_CMR_T;
Xtypedef volatile uint32_t PWM_CMR_T;
N
Ntypedef __IO uint32_t PWM_PDR_T;
Xtypedef volatile uint32_t PWM_PDR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  PWMIE0:1;
X    volatile uint32_t  PWMIE0:1;
N    __IO uint32_t  PWMIE1:1;
X    volatile uint32_t  PWMIE1:1;
N    __IO uint32_t  PWMIE2:1;
X    volatile uint32_t  PWMIE2:1;
N    __IO uint32_t  PWMIE3:1;
X    volatile uint32_t  PWMIE3:1;
N	__I  uint32_t  RESERVE:28;
X	volatile const  uint32_t  RESERVE:28;
N} PWM_PIER_T;
N
Ntypedef struct
N{
N    __IO uint32_t  PWMIF0:1;
X    volatile uint32_t  PWMIF0:1;
N    __IO uint32_t  PWMIF1:1;
X    volatile uint32_t  PWMIF1:1;
N    __IO uint32_t  PWMIF2:1;
X    volatile uint32_t  PWMIF2:1;
N    __IO uint32_t  PWMIF3:1;
X    volatile uint32_t  PWMIF3:1;
N	__I  uint32_t  RESERVE:28;
X	volatile const  uint32_t  RESERVE:28;
N} PWM_PIFR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  INV0:1;
X    volatile uint32_t  INV0:1;
N    __IO uint32_t  CRL_IE0:1;
X    volatile uint32_t  CRL_IE0:1;
N    __IO uint32_t  CFL_IE0:1;
X    volatile uint32_t  CFL_IE0:1;
N    __IO uint32_t  CAPCH0EN:1;
X    volatile uint32_t  CAPCH0EN:1;
N    __IO uint32_t  CAPIF0:1;
X    volatile uint32_t  CAPIF0:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  CRLRI0:1;
X    volatile uint32_t  CRLRI0:1;
N    __IO uint32_t  CFLRI0:1;
X    volatile uint32_t  CFLRI0:1;
N    __I  uint32_t  RESERVE1:8;
X    volatile const  uint32_t  RESERVE1:8;
N    __IO uint32_t  INV1:1;
X    volatile uint32_t  INV1:1;
N    __IO uint32_t  CRL_IE1:1;
X    volatile uint32_t  CRL_IE1:1;
N    __IO uint32_t  CFL_IE1:1;
X    volatile uint32_t  CFL_IE1:1;
N    __IO uint32_t  CAPCH1EN:1;
X    volatile uint32_t  CAPCH1EN:1;
N    __IO uint32_t  CAPIF1:1;
X    volatile uint32_t  CAPIF1:1;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  CRLRI1:1;
X    volatile uint32_t  CRLRI1:1;
N    __IO uint32_t  CFLRI1:1;
X    volatile uint32_t  CFLRI1:1;
N    __I  uint32_t  RESERVE3:8;
X    volatile const  uint32_t  RESERVE3:8;
N} PWM_CCR0_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  INV2:1;
X    volatile uint32_t  INV2:1;
N    __IO uint32_t  CRL_IE2:1;
X    volatile uint32_t  CRL_IE2:1;
N    __IO uint32_t  CFL_IE2:1;
X    volatile uint32_t  CFL_IE2:1;
N    __IO uint32_t  CAPCH2EN:1;
X    volatile uint32_t  CAPCH2EN:1;
N    __IO uint32_t  CAPIF2:1;
X    volatile uint32_t  CAPIF2:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  CRLRI2:1;
X    volatile uint32_t  CRLRI2:1;
N    __IO uint32_t  CFLRI2:1;
X    volatile uint32_t  CFLRI2:1;
N    __I  uint32_t  RESERVE1:8;
X    volatile const  uint32_t  RESERVE1:8;
N    __IO uint32_t  INV3:1;
X    volatile uint32_t  INV3:1;
N    __IO uint32_t  CRL_IE3:1;
X    volatile uint32_t  CRL_IE3:1;
N    __IO uint32_t  CFL_IE3:1;
X    volatile uint32_t  CFL_IE3:1;
N    __IO uint32_t  CAPCH3EN:1;
X    volatile uint32_t  CAPCH3EN:1;
N    __IO uint32_t  CAPIF3:1;
X    volatile uint32_t  CAPIF3:1;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  CRLRI3:1;
X    volatile uint32_t  CRLRI3:1;
N    __IO uint32_t  CFLRI3:1;
X    volatile uint32_t  CFLRI3:1;
N    __I  uint32_t  RESERVE3:8;
X    volatile const  uint32_t  RESERVE3:8;
N} PWM_CCR1_T;
N
Ntypedef __IO uint32_t PWM_CRLR_T;
Xtypedef volatile uint32_t PWM_CRLR_T;
N
Ntypedef __IO uint32_t PWM_CFLR_T;
Xtypedef volatile uint32_t PWM_CFLR_T;
N
Ntypedef __IO uint32_t PWM_CAPENR_T;
Xtypedef volatile uint32_t PWM_CAPENR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  PWM0:1;
X    volatile uint32_t  PWM0:1;
N    __IO uint32_t  PWM1:1;
X    volatile uint32_t  PWM1:1;
N    __IO uint32_t  PWM2:1;
X    volatile uint32_t  PWM2:1;
N    __IO uint32_t  PWM3:1;
X    volatile uint32_t  PWM3:1;
N	__I  uint32_t  RESERVE:28;
X	volatile const  uint32_t  RESERVE:28;
N} PWM_POE_T;
N
N
Ntypedef struct
N{
N    PWM_PPR_T       PPR;                // 0x00
N    PWM_CSR_T       CSR;                // 0x04
N    PWM_PCR_T       PCR;                // 0x08
N    PWM_CNR_T       CNR0;               // 0x0C
N    PWM_CMR_T       CMR0;               // 0x10
N    PWM_PDR_T       PDR0;               // 0x14
N    PWM_CNR_T       CNR1;               // 0x18
N    PWM_CMR_T       CMR1;               // 0x1C
N    PWM_PDR_T       PDR1;               // 0x20
N    PWM_CNR_T       CNR2;               // 0x24
N    PWM_CMR_T       CMR2;               // 0x28
N    PWM_PDR_T       PDR2;               // 0x2C
N    PWM_CNR_T       CNR3;               // 0x30
N    PWM_CMR_T       CMR3;               // 0x34
N    PWM_PDR_T       PDR3;               // 0x38
N    __I uint32_t    RESERVE0;
X    volatile const uint32_t    RESERVE0;
N    PWM_PIER_T      PIER;               // 0x40
N    PWM_PIFR_T      PIFR;               // 0x44
N    __I uint32_t    RESERVE1[2];
X    volatile const uint32_t    RESERVE1[2];
N    PWM_CCR0_T      CCR0;               // 0x50
N    PWM_CCR1_T      CCR1;               // 0x54
N    PWM_CRLR_T      CRLR0;              // 0x58
N    PWM_CFLR_T      CFLR0;              // 0x5C
N    PWM_CRLR_T      CRLR1;              // 0x60
N    PWM_CFLR_T      CFLR1;              // 0x64
N    PWM_CRLR_T      CRLR2;              // 0x68
N    PWM_CFLR_T      CFLR2;              // 0x6C
N    PWM_CRLR_T      CRLR3;              // 0x70
N    PWM_CFLR_T      CFLR3;              // 0x74
N    PWM_CAPENR_T    CAPENR;             // 0x78
N    PWM_POE_T       POE;                // 0x7C
N} PWM_T;
N
N
N/* PWM PPR Bit Field Definitions */
N#define PWM_PPR_DZI23_Pos                       24
N#define PWM_PPR_DZI23_Msk                       (0xFFul << PWM_PPR_DZI23_Pos)
N
N#define PWM_PPR_DZI01_Pos                       16
N#define PWM_PPR_DZI01_Msk                       (0xFFul << PWM_PPR_DZI01_Pos)
N
N#define PWM_PPR_CP23_Pos                        8
N#define PWM_PPR_CP23_Msk                        (0xFFul << PWM_PPR_CP23_Pos)
N
N#define PWM_PPR_CP01_Pos                        0
N#define PWM_PPR_CP01_Msk                        (0xFFul << PWM_PPR_CP01_Pos)
N
N/* PWM CSR Bit Field Definitions */
N#define PWM_CSR_CSR3_Pos                        12
N#define PWM_CSR_CSR3_Msk                        (7ul << PWM_CSR_CSR3_Pos)
N
N#define PWM_CSR_CSR2_Pos                        8
N#define PWM_CSR_CSR2_Msk                        (7ul << PWM_CSR_CSR2_Pos)
N
N#define PWM_CSR_CSR1_Pos                        4
N#define PWM_CSR_CSR1_Msk                        (7ul << PWM_CSR_CSR1_Pos)
N
N#define PWM_CSR_CSR0_Pos                        0
N#define PWM_CSR_CSR0_Msk                        (7ul << PWM_CSR_CSR0_Pos)
N
N/* PWM PCR Bit Field Definitions */
N#define PWM_PCR_CH3MOD_Pos                      27
N#define PWM_PCR_CH3MOD_Msk                      (1ul << PWM_PCR_CH3MOD_Pos)
N
N#define PWM_PCR_CH3INV_Pos                      26
N#define PWM_PCR_CH3INV_Msk                      (1ul << PWM_PCR_CH3INV_Pos)
N
N#define PWM_PCR_CH3EN_Pos                       24
N#define PWM_PCR_CH3EN_Msk                       (1ul << PWM_PCR_CH3EN_Pos)
N
N#define PWM_PCR_CH2MOD_Pos                      19
N#define PWM_PCR_CH2MOD_Msk                      (1ul << PWM_PCR_CH2MOD_Pos)
N
N#define PWM_PCR_CH2INV_Pos                      18
N#define PWM_PCR_CH2INV_Msk                      (1ul << PWM_PCR_CH2INV_Pos)
N
N#define PWM_PCR_CH2EN_Pos                       16
N#define PWM_PCR_CH2EN_Msk                       (1ul << PWM_PCR_CH2EN_Pos)
N
N#define PWM_PCR_CH1MOD_Pos                      11
N#define PWM_PCR_CH1MOD_Msk                      (1ul << PWM_PCR_CH1MOD_Pos)
N
N#define PWM_PCR_CH1INV_Pos                      10
N#define PWM_PCR_CH1INV_Msk                      (1ul << PWM_PCR_CH1INV_Pos)
N
N#define PWM_PCR_CH1EN_Pos                       8
N#define PWM_PCR_CH1EN_Msk                       (1ul << PWM_PCR_CH1EN_Pos)
N
N#define PWM_PCR_DZEN23_Pos                      5
N#define PWM_PCR_DZEN23_Msk                      (1ul << PWM_PCR_DZEN23_Pos)
N
N#define PWM_PCR_DZEN01_Pos                      4
N#define PWM_PCR_DZEN01_Msk                      (1ul << PWM_PCR_DZEN01_Pos)
N
N#define PWM_PCR_CH0MOD_Pos                      3
N#define PWM_PCR_CH0MOD_Msk                      (1ul << PWM_PCR_CH0MOD_Pos)
N
N#define PWM_PCR_CH0INV_Pos                      2
N#define PWM_PCR_CH0INV_Msk                      (1ul << PWM_PCR_CH0INV_Pos)
N
N#define PWM_PCR_CH0EN_Pos                       0
N#define PWM_PCR_CH0EN_Msk                       (1ul << PWM_PCR_CH0EN_Pos)
N
N/* PWM CNR Bit Field Definitions */
N#define PWM_CNR_CNR_Pos                         0
N#define PWM_CNR_CNR_Msk                         (0xFFFFul << PWM_CNR_CNR_Pos)
N
N/* PWM CMR Bit Field Definitions */
N#define PWM_CMR_CMR_Pos                         0
N#define PWM_CMR_CMR_Msk                         (0xFFFFul << PWM_CMR_CMR_Pos)
N
N/* PWM PDR Bit Field Definitions */
N#define PWM_PDR_PDR_Pos                         0
N#define PWM_PDR_PDR_Msk                         (0xFFFFul << PWM_PDR_PDR_Pos)
N
N/* PWM PBCR Bit Field Definitions */
N#define PWM_PBCR_BCn_Pos                        0
N#define PWM_PBCR_BCn_Msk                        (1ul << PWM_PBCR_BCn_Pos)
N
N/* PWM PIER Bit Field Definitions */
N#define PWM_PIER_PWMIE3_Pos                     3
N#define PWM_PIER_PWMIE3_Msk                     (1ul << PWM_PIER_PWMIE3_Pos)
N
N#define PWM_PIER_PWMIE2_Pos                     2
N#define PWM_PIER_PWMIE2_Msk                     (1ul << PWM_PIER_PWMIE2_Pos)
N
N#define PWM_PIER_PWMIE1_Pos                     1
N#define PWM_PIER_PWMIE1_Msk                     (1ul << PWM_PIER_PWMIE1_Pos)
N
N#define PWM_PIER_PWMIE0_Pos                     0
N#define PWM_PIER_PWMIE0_Msk                     (1ul << PWM_PIER_PWMIE0_Pos)
N
N/* PWM PIIR Bit Field Definitions */
N#define PWM_PIIR_PWMIF3_Pos                     3
N#define PWM_PIIR_PWMIF3_Msk                     (1ul << PWM_PIIR_PWMIF3_Pos)
N
N#define PWM_PIIR_PWMIF2_Pos                     2
N#define PWM_PIIR_PWMIF2_Msk                     (1ul << PWM_PIIR_PWMIF2_Pos)
N
N#define PWM_PIIR_PWMIF1_Pos                     1
N#define PWM_PIIR_PWMIF1_Msk                     (1ul << PWM_PIIR_PWMIF1_Pos)
N
N#define PWM_PIIR_PWMIF0_Pos                     0
N#define PWM_PIIR_PWMIF0_Msk                     (1ul << PWM_PIIR_PWMIF0_Pos)
N
N/* PWM CCR0 Bit Field Definitions */
N#define PWM_CCR0_CFLRI1_Pos                     23
N#define PWM_CCR0_CFLRI1_Msk                     (1ul << PWM_CCR0_CFLRI1_Pos)
N
N#define PWM_CCR0_CRLRI1_Pos                     22
N#define PWM_CCR0_CRLRI1_Msk                     (1ul << PWM_CCR0_CRLRI1_Pos)
N
N#define PWM_CCR0_CAPIF1_Pos                     20
N#define PWM_CCR0_CAPIF1_Msk                     (1ul << PWM_CCR0_CAPIF1_Pos)
N
N#define PWM_CCR0_CAPCH1EN_Pos                   19
N#define PWM_CCR0_CAPCH1EN_Msk                   (1ul << PWM_CCR0_CAPCH1EN_Pos)
N
N#define PWM_CCR0_CFL_IE1_Pos                    18
N#define PWM_CCR0_CFL_IE1_Msk                    (1ul << PWM_CCR0_CFL_IE1_Pos)
N
N#define PWM_CCR0_CRL_IE1_Pos                    17
N#define PWM_CCR0_CRL_IE1_Msk                    (1ul << PWM_CCR0_CRL_IE1_Pos)
N
N#define PWM_CCR0_INV1_Pos                       16
N#define PWM_CCR0_INV1_Msk                       (1ul << PWM_CCR0_INV1_Pos)
N
N#define PWM_CCR0_CFLRI0_Pos                     7
N#define PWM_CCR0_CFLRI0_Msk                     (1ul << PWM_CCR0_CFLRI0_Pos)
N
N#define PWM_CCR0_CRLRI0_Pos                     6
N#define PWM_CCR0_CRLRI0_Msk                     (1ul << PWM_CCR0_CRLRI0_Pos)
N
N#define PWM_CCR0_CAPIF0_Pos                     4
N#define PWM_CCR0_CAPIF0_Msk                     (1ul << PWM_CCR0_CAPIF0_Pos)
N
N#define PWM_CCR0_CAPCH0EN_Pos                   3
N#define PWM_CCR0_CAPCH0EN_Msk                   (1ul << PWM_CCR0_CAPCH0EN_Pos)
N
N#define PWM_CCR0_CFL_IE0_Pos                    2
N#define PWM_CCR0_CFL_IE0_Msk                    (1ul << PWM_CCR0_CFL_IE0_Pos)
N
N#define PWM_CCR0_CRL_IE0_Pos                    1
N#define PWM_CCR0_CRL_IE0_Msk                    (1ul << PWM_CCR0_CRL_IE0_Pos)
N
N#define PWM_CCR0_INV0_Pos                       0
N#define PWM_CCR0_INV0_Msk                       (1ul << PWM_CCR0_INV0_Pos)
N
N/* PWM CCR2 Bit Field Definitions */
N#define PWM_CCR2_CFLRI3_Pos                     23
N#define PWM_CCR2_CFLRI3_Msk                     (1ul << PWM_CCR2_CFLRI3_Pos)
N
N#define PWM_CCR2_CRLRI3_Pos                     22
N#define PWM_CCR2_CRLRI3_Msk                     (1ul << PWM_CCR2_CRLRI3_Pos)
N
N#define PWM_CCR2_CAPIF3_Pos                     20
N#define PWM_CCR2_CAPIF3_Msk                     (1ul << PWM_CCR2_CAPIF3_Pos)
N
N#define PWM_CCR2_CAPCH3EN_Pos                   19
N#define PWM_CCR2_CAPCH3EN_Msk                   (1ul << PWM_CCR2_CAPCH3EN_Pos)
N
N#define PWM_CCR2_CFL_IE3_Pos                    18
N#define PWM_CCR2_CFL_IE3_Msk                    (1ul << PWM_CCR2_CFL_IE3_Pos)
N
N#define PWM_CCR2_CRL_IE3_Pos                    17
N#define PWM_CCR2_CRL_IE3_Msk                    (1ul << PWM_CCR2_CRL_IE3_Pos)
N
N#define PWM_CCR2_INV3_Pos                       16
N#define PWM_CCR2_INV3_Msk                       (1ul << PWM_CCR2_INV3_Pos)
N
N#define PWM_CCR2_CFLRI2_Pos                     7
N#define PWM_CCR2_CFLRI2_Msk                     (1ul << PWM_CCR2_CFLRI2_Pos)
N
N#define PWM_CCR2_CRLRI2_Pos                     6
N#define PWM_CCR2_CRLRI2_Msk                     (1ul << PWM_CCR2_CRLRI2_Pos)
N
N#define PWM_CCR2_CAPIF2_Pos                     4
N#define PWM_CCR2_CAPIF2_Msk                     (1ul << PWM_CCR2_CAPIF2_Pos)
N
N#define PWM_CCR2_CAPCH2EN_Pos                   3
N#define PWM_CCR2_CAPCH2EN_Msk                   (1ul << PWM_CCR2_CAPCH2EN_Pos)
N
N#define PWM_CCR2_CFL_IE2_Pos                    2
N#define PWM_CCR2_CFL_IE2_Msk                    (1ul << PWM_CCR2_CFL_IE2_Pos)
N
N#define PWM_CCR2_CRL_IE2_Pos                    1
N#define PWM_CCR2_CRL_IE2_Msk                    (1ul << PWM_CCR2_CRL_IE2_Pos)
N
N#define PWM_CCR2_INV2_Pos                       0
N#define PWM_CCR2_INV2_Msk                       (1ul << PWM_CCR2_INV2_Pos)
N
N/* PWM CRLR Bit Field Definitions */
N#define PWM_CRLR_CRLR_Pos                       0
N#define PWM_CRLR_CRLR_Msk                       (0xFFFFul << PWM_CRLR_CRLR_Pos)
N
N/* PWM CFLR Bit Field Definitions */
N#define PWM_CFLR_CFLR_Pos                       0
N#define PWM_CFLR_CFLR_Msk                       (0xFFFFul << PWM_CFLR_CFLR_Pos)
N
N/* PWM CAPENR Bit Field Definitions */
N#define PWM_CAPENR_CAPENR_Pos                   0
N#define PWM_CAPENR_CAPENR_Msk                   (0xFul << PWM_CAPENR_CAPENR_Pos)
N
N/* PWM POE Bit Field Definitions */
N#define PWM_POE_PWM3_Pos                        3
N#define PWM_POE_PWM3_Msk                        (1ul << PWM_POE_PWM3_Pos)
N
N#define PWM_POE_PWM2_Pos                        2
N#define PWM_POE_PWM2_Msk                        (1ul << PWM_POE_PWM2_Pos)
N
N#define PWM_POE_PWM1_Pos                        1
N#define PWM_POE_PWM1_Msk                        (1ul << PWM_POE_PWM1_Pos)
N
N#define PWM_POE_PWM0_Pos                        0
N#define PWM_POE_PWM0_Msk                        (1ul << PWM_POE_PWM0_Pos)
N
N//---------------------------- Audio Digital PWM (DPWM) ------------------------
Ntypedef struct
N{
N    __IO uint32_t Freq:3;
X    volatile uint32_t Freq:3;
N    __IO uint32_t Deadtime:1;
X    volatile uint32_t Deadtime:1;
N    __IO uint32_t Dither:2;
X    volatile uint32_t Dither:2;
N    __IO uint32_t Enable:1;
X    volatile uint32_t Enable:1;
N	__IO uint32_t EnGPIO:1;
X	volatile uint32_t EnGPIO:1;
N    __I  uint32_t RESERVE:24;
X    volatile const  uint32_t RESERVE:24;
N} DPWM_CTRL_T;
N
Ntypedef struct
N{
N    __I uint32_t Full:1;
X    volatile const uint32_t Full:1;
N    __I uint32_t Empty:1;
X    volatile const uint32_t Empty:1;
N    __I uint32_t RESERVE:30;
X    volatile const uint32_t RESERVE:30;
N}DPWM_STAT_T;
Ntypedef struct
N{
N    __IO uint32_t EnablePDMA:1;
X    volatile uint32_t EnablePDMA:1;
N    __I  uint32_t RESERVE:31;
X    volatile const  uint32_t RESERVE:31;
N}DPWM_PDMA_T;
N//---------------------------------------
N//	DPWM->FIFO is writtable	only
N//     It is a 16-deep fifo each 16bit wide
N//  ZOH_DIV is the upsample ratio of the zeroth order hold
N//     The consumption rate of the PWM_fifo is calculated by
N//     Freq(HCLK) / (ZOH_DIV * 64), where 64 is the upsampling ratio of the CIC filter
N//
N//----------------------------------------
N
Ntypedef struct
N{
N    DPWM_CTRL_T CTRL;
N    DPWM_STAT_T STAT;
N    DPWM_PDMA_T DMA;
N    __O uint32_t FIFO;
X    volatile uint32_t FIFO;
N    __IO uint32_t ZOH_DIV;
X    volatile uint32_t ZOH_DIV;
N} DPWM_T;
N
N/*----------------------------- I2S Controller -------------------------------*/
N
Ntypedef struct
N{
N    __IO uint32_t  I2SEN:1;
X    volatile uint32_t  I2SEN:1;
N    __IO uint32_t  TXEN:1;
X    volatile uint32_t  TXEN:1;
N    __IO uint32_t  RXEN:1;
X    volatile uint32_t  RXEN:1;
N    __IO uint32_t  MUTE:1;
X    volatile uint32_t  MUTE:1;
N    __IO uint32_t  WORDWIDTH:2;
X    volatile uint32_t  WORDWIDTH:2;
N    __IO uint32_t  MONO:1;
X    volatile uint32_t  MONO:1;
N    __IO uint32_t  FORMAT:1;
X    volatile uint32_t  FORMAT:1;
N    __IO uint32_t  SLAVE:1;
X    volatile uint32_t  SLAVE:1;
N    __IO uint32_t  TXTH:3;
X    volatile uint32_t  TXTH:3;
N    __IO uint32_t  RXTH:3;
X    volatile uint32_t  RXTH:3;
N    __IO uint32_t  MCLKEN:1;
X    volatile uint32_t  MCLKEN:1;
N    __IO uint32_t  RCHZCEN:1;
X    volatile uint32_t  RCHZCEN:1;
N    __IO uint32_t  LCHZCEN:1;
X    volatile uint32_t  LCHZCEN:1;
N    __IO uint32_t  CLR_TXFIFO:1;
X    volatile uint32_t  CLR_TXFIFO:1;
N    __IO uint32_t  CLR_RXFIFO:1;
X    volatile uint32_t  CLR_RXFIFO:1;
N    __IO uint32_t  TXDMA:1;
X    volatile uint32_t  TXDMA:1;
N    __IO uint32_t  RXDMA:1;
X    volatile uint32_t  RXDMA:1;
N    __I  uint32_t  RESERVE:10;
X    volatile const  uint32_t  RESERVE:10;
N} I2S_CON_T;
N
Ntypedef struct
N{
N    __IO uint32_t  MCLK_DIV:3;
X    volatile uint32_t  MCLK_DIV:3;
N    __I  uint32_t  RESERVE0:5;
X    volatile const  uint32_t  RESERVE0:5;
N    __IO uint32_t  BCLK_DIV:8;
X    volatile uint32_t  BCLK_DIV:8;
N    __I  uint32_t  RESERVE1:16;
X    volatile const  uint32_t  RESERVE1:16;
N} I2S_CLKDIV_T;
N
Ntypedef struct
N{
N    __IO uint32_t  RXUDFIE:1;
X    volatile uint32_t  RXUDFIE:1;
N    __IO uint32_t  RXOVFIE:1;
X    volatile uint32_t  RXOVFIE:1;
N    __IO uint32_t  RXTHIE:1;
X    volatile uint32_t  RXTHIE:1;
N    __I  uint32_t  RESERVE0:5;
X    volatile const  uint32_t  RESERVE0:5;
N    __IO uint32_t  TXUDFIE:1;
X    volatile uint32_t  TXUDFIE:1;
N    __IO uint32_t  TXOVFIE:1;
X    volatile uint32_t  TXOVFIE:1;
N    __IO uint32_t  TXTHIE:1;
X    volatile uint32_t  TXTHIE:1;
N    __IO uint32_t  RZCIE:1;
X    volatile uint32_t  RZCIE:1;
N    __IO uint32_t  LZCIE:1;
X    volatile uint32_t  LZCIE:1;
N    __I  uint32_t  RESERVE1:19;
X    volatile const  uint32_t  RESERVE1:19;
N} I2S_IE_T;
N
Ntypedef struct
N{
N    __I  uint32_t  I2SINT:1;
X    volatile const  uint32_t  I2SINT:1;
N    __I  uint32_t  I2SRXINT:1;
X    volatile const  uint32_t  I2SRXINT:1;
N    __I  uint32_t  I2STXINT:1;
X    volatile const  uint32_t  I2STXINT:1;
N    __I  uint32_t  RIGHT:1;
X    volatile const  uint32_t  RIGHT:1;
N    __I  uint32_t  RESERVE0:4;
X    volatile const  uint32_t  RESERVE0:4;
N    __IO uint32_t  RXUDF:1;
X    volatile uint32_t  RXUDF:1;
N    __IO uint32_t  RXOVF:1;
X    volatile uint32_t  RXOVF:1;
N    __I  uint32_t  RXTHF:1;
X    volatile const  uint32_t  RXTHF:1;
N    __I  uint32_t  RXFULL:1;
X    volatile const  uint32_t  RXFULL:1;
N    __I  uint32_t  RXEMPTY:1;
X    volatile const  uint32_t  RXEMPTY:1;
N    __I  uint32_t  RESERVE1:3;
X    volatile const  uint32_t  RESERVE1:3;
N    __IO uint32_t  TXUDF:1;
X    volatile uint32_t  TXUDF:1;
N    __IO uint32_t  TXOVF:1;
X    volatile uint32_t  TXOVF:1;
N    __I  uint32_t  TXTHF:1;
X    volatile const  uint32_t  TXTHF:1;
N    __I  uint32_t  TXFULL:1;
X    volatile const  uint32_t  TXFULL:1;
N    __I  uint32_t  TXEMPTY:1;
X    volatile const  uint32_t  TXEMPTY:1;
N    __I  uint32_t  TXBUSY:1;
X    volatile const  uint32_t  TXBUSY:1;
N    __IO uint32_t  RZCF:1;
X    volatile uint32_t  RZCF:1;
N    __IO uint32_t  LZCF:1;
X    volatile uint32_t  LZCF:1;
N    __I  uint32_t  RX_LEVEL:4;
X    volatile const  uint32_t  RX_LEVEL:4;
N    __I  uint32_t  TX_LEVEL:4;
X    volatile const  uint32_t  TX_LEVEL:4;
N} I2S_STATUS_T;
N
Ntypedef __O uint32_t I2S_TXFIFO_T;
Xtypedef volatile uint32_t I2S_TXFIFO_T;
Ntypedef __I uint32_t I2S_RXFIFO_T;
Xtypedef volatile const uint32_t I2S_RXFIFO_T;
N
Ntypedef struct
N{
N    I2S_CON_T        CON;
N    I2S_CLKDIV_T     CLKDIV;
N    I2S_IE_T      	 IE;
N    I2S_STATUS_T     STATUS;
N    I2S_TXFIFO_T     TXFIFO;
N    I2S_RXFIFO_T     RXFIFO;
N} I2S_T;
N
N/*----------------------------- Analog Controller -------------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  PULLDOWN:1;
X    volatile uint32_t  PULLDOWN:1;
N    __IO uint32_t  PDLORES:1;
X    volatile uint32_t  PDLORES:1;
N    __IO uint32_t  PDHIRES:1;
X    volatile uint32_t  PDHIRES:1;
N    __I  uint32_t  RESERVE:29;
X    volatile const  uint32_t  RESERVE:29;
N
N} ANA_VMID_T;
N
Ntypedef struct
N{
N    __IO uint32_t  FM_SEL:2;
X    volatile uint32_t  FM_SEL:2;
N    __I  uint32_t  FM_DONE:1;
X    volatile const  uint32_t  FM_DONE:1;
N    __I  uint32_t  RESERVE:13;
X    volatile const  uint32_t  RESERVE:13;
N    __IO uint32_t  FM_CYCLE:8;
X    volatile uint32_t  FM_CYCLE:8;
N    __I  uint32_t  RESERVE1:7;
X    volatile const  uint32_t  RESERVE1:7;
N    __IO uint32_t  FM_GO:1;
X    volatile uint32_t  FM_GO:1;
N} FREQ_MEAS_T;
N
Ntypedef struct
N{
N    __IO uint32_t  LOW_TIME:2;	     // [1:0] 00=1, 01=2, 10=8, 11=16
X    volatile uint32_t  LOW_TIME:2;	     
N    __IO uint32_t  CYCLE_CNT:3;		 // [4:2] =2^CYCLE_CNT
X    volatile uint32_t  CYCLE_CNT:3;		 
N    __IO uint32_t  REF_CLK_MODE:1;	 // [5]
X    volatile uint32_t  REF_CLK_MODE:1;	 
N    __I  uint32_t  RESERVE0:2;		 // [7:6]
X    volatile const  uint32_t  RESERVE0:2;		 
N    __IO uint32_t  CLK_DIV:8;		 // [15:8]
X    volatile uint32_t  CLK_DIV:8;		 
N    __I  uint32_t  RESERVE:13;		 // [28:16]
X    volatile const  uint32_t  RESERVE:13;		 
N    __IO uint32_t  RST_CNT:1;		 // [29]
X    volatile uint32_t  RST_CNT:1;		 
N    __IO uint32_t  INT_EN:1;		 // [30]
X    volatile uint32_t  INT_EN:1;		 
N    __IO uint32_t  CNT_EN:1;		 // [31]
X    volatile uint32_t  CNT_EN:1;		 
N} CAPS_CTRL_T;
N
Ntypedef struct
N{
N    __IO uint32_t  EN:8;
X    volatile uint32_t  EN:8;
N    __IO uint32_t  VAL:2;
X    volatile uint32_t  VAL:2;
N    __I  uint32_t  RESERVE:22;
X    volatile const  uint32_t  RESERVE:22;
N
N} ISRC_CTRL_T;
Ntypedef struct
N{
N    __IO uint32_t  EN:16;
X    volatile uint32_t  EN:16;
N    __I  uint32_t  RESERVE:16;
X    volatile const  uint32_t  RESERVE:16;
N
N} ISRC_CTRL1_T;
N
Ntypedef struct
N{
N    __IO uint32_t  PD:1;
X    volatile uint32_t  PD:1;
N    __IO uint32_t  DISCH:1;
X    volatile uint32_t  DISCH:1;
N    __I  uint32_t  RESERVE:30;
X    volatile const  uint32_t  RESERVE:30;
N
N} LDO_PD_T;
N
Ntypedef struct
N{
N    __IO uint32_t  MUXN_SEL:8;
X    volatile uint32_t  MUXN_SEL:8;
N    __IO uint32_t  MUXP_SEL:4;
X    volatile uint32_t  MUXP_SEL:4;
N    __IO uint32_t  TEMP_SEL:1;
X    volatile uint32_t  TEMP_SEL:1;
N    __IO uint32_t  MIC_SEL:1;
X    volatile uint32_t  MIC_SEL:1;
N    __IO uint32_t  EN:1;
X    volatile uint32_t  EN:1;
N    __I  uint32_t  RESERVE:17;
X    volatile const  uint32_t  RESERVE:17;
N} ANA_AMUX_T;
N
N
N
N
Ntypedef struct
N{
N    __I  uint8_t   OSCTRIM;
X    volatile const  uint8_t   OSCTRIM;
N    __I  uint8_t   COARSE;
X    volatile const  uint8_t   COARSE;
N    __IO int8_t    SUPERFINE;
X    volatile int8_t    SUPERFINE;
N    __I  uint8_t   RESERVE;
X    volatile const  uint8_t   RESERVE;
N} ANA_OSCTRIM_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  REF_SEL:1;
X    volatile uint32_t  REF_SEL:1;
N    __IO uint32_t  PU_PGA:1;
X    volatile uint32_t  PU_PGA:1;
N    __IO uint32_t  PU_IPBOOST:1;
X    volatile uint32_t  PU_IPBOOST:1;
N    __IO uint32_t  BOOSTGAIN:1;
X    volatile uint32_t  BOOSTGAIN:1;
N    __I  uint32_t  RESERVE:28;
X    volatile const  uint32_t  RESERVE:28;
N} ANA_PGAEN_T;
N
Ntypedef struct
N{
N    __IO uint32_t  PU_ZCD:1;
X    volatile uint32_t  PU_ZCD:1;
N    __IO uint32_t  PU_BUFPGA:1;
X    volatile uint32_t  PU_BUFPGA:1;
N    __IO uint32_t  PU_BUFADC:1;
X    volatile uint32_t  PU_BUFADC:1;
N    __IO uint32_t  PU_IBGEN:1;
X    volatile uint32_t  PU_IBGEN:1;
N    __IO uint32_t  PU_MOD:1;
X    volatile uint32_t  PU_MOD:1;
N    __IO uint32_t  MUTE_PGA:1;
X    volatile uint32_t  MUTE_PGA:1;
N    __IO uint32_t  MUTE_IPBOOST:1;
X    volatile uint32_t  MUTE_IPBOOST:1;
N    __I  uint32_t  RESERVE:25;
X    volatile const  uint32_t  RESERVE:25;
N} ANA_SIGCTRL_T;
N
Ntypedef struct
N{
N    __IO uint32_t  GAIN:6;
X    volatile uint32_t  GAIN:6;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __I  uint32_t  GAIN_READ:6;
X    volatile const  uint32_t  GAIN_READ:6;
N    __I  uint32_t  RESERVE1:18;
X    volatile const  uint32_t  RESERVE1:18;
N
N} ANA_PGAGAIN_T;
N
Ntypedef struct
N{
N    ANA_VMID_T      VMID;           // 00
N    __I  uint32_t	RESERVE0;       // 04
X    volatile const  uint32_t	RESERVE0;       
N    ISRC_CTRL_T		ISRC;           // 08
N    ISRC_CTRL1_T	ISRC1;          // 0C
N    __I  uint32_t	RESERVE1[4];    // 10-1C
X    volatile const  uint32_t	RESERVE1[4];    
N    __IO uint32_t	LDOSET;         // 20
X    volatile uint32_t	LDOSET;         
N    LDO_PD_T    	LDOPD;          // 24
N    __IO uint32_t	MICBSEL;		// 28
X    volatile uint32_t	MICBSEL;		
N    __IO uint32_t	MICBEN;			// 2C
X    volatile uint32_t	MICBEN;			
N    __I  uint32_t	RESERVE2[2];	// 30-34
X    volatile const  uint32_t	RESERVE2[2];	
N    __IO uint32_t	VSET;			// 38
X    volatile uint32_t	VSET;			
N    __IO uint32_t	TMPOWER;		// 3C
X    volatile uint32_t	TMPOWER;		
N    __IO uint32_t	TMANALOG;		// 40
X    volatile uint32_t	TMANALOG;		
N    __I  uint32_t	RESERVE3[3];	// 44-4C
X    volatile const  uint32_t	RESERVE3[3];	
N    ANA_AMUX_T		AMUX;			// 50
N	__IO uint32_t	AMUX_B1;		// 54
X	volatile uint32_t	AMUX_B1;		
N    __I  uint32_t	RESERVE4[2];	// 58-5C
X    volatile const  uint32_t	RESERVE4[2];	
N    ANA_PGAEN_T 	PGAEN;			// 60
N    ANA_SIGCTRL_T	SIGCTRL;		// 64
N    ANA_PGAGAIN_T	PGA_GAIN;		// 68
N    __I  uint32_t	RESERVE5[5];	// 6C-7C
X    volatile const  uint32_t	RESERVE5[5];	
N    __IO uint32_t	TMOSC;			// 80
X    volatile uint32_t	TMOSC;			
N    ANA_OSCTRIM_T	TRIM;			// 84
N    __I  uint32_t	FINETRIM;		// 88
X    volatile const  uint32_t	FINETRIM;		
N    CAPS_CTRL_T 	CAPS_CTRL;		// 8C
N    __I  uint32_t	CAPS_CNT;		// 90
X    volatile const  uint32_t	CAPS_CNT;		
N    FREQ_MEAS_T   	FREQ_CTRL;		// 94
N    __I  uint32_t	FREQ_CNT;		// 98
X    volatile const  uint32_t	FREQ_CNT;		
N    __IO uint32_t	FREQ_CYCLE;		// 9C
X    volatile uint32_t	FREQ_CYCLE;		
N} ANA_T;
N
N/*------------------------------- BOD Controller -------------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  BOD_LVL:3;
X    volatile uint32_t  BOD_LVL:3;
N    __IO uint32_t  BOD_HYS:1;
X    volatile uint32_t  BOD_HYS:1;
N    __IO uint32_t  BOD_RANGE:1;
X    volatile uint32_t  BOD_RANGE:1;
N    __I  uint32_t  RESERVE:27;
X    volatile const  uint32_t  RESERVE:27;
N} BOD_SEL_T;
N
Ntypedef struct
N{
N    __IO uint32_t  EN:2;
X    volatile uint32_t  EN:2;
N    __IO uint32_t  IE:1;
X    volatile uint32_t  IE:1;
N    __IO uint32_t  INT:1;
X    volatile uint32_t  INT:1;
N    __I  uint32_t  BOD_OUT:1;
X    volatile const  uint32_t  BOD_OUT:1;
N    __I  uint32_t  RESERVE:27;
X    volatile const  uint32_t  RESERVE:27;
N} BOD_EN_T;
N
Ntypedef struct
N{
N    __IO uint32_t  OFF_DUR:16;
X    volatile uint32_t  OFF_DUR:16;
N    __IO uint32_t  ON_DUR:4;
X    volatile uint32_t  ON_DUR:4;
N    __I  uint32_t  RESERVE:12;
X    volatile const  uint32_t  RESERVE:12;
N} DET_TIMER_T;
N
Ntypedef struct
N{
N    BOD_SEL_T     BOD_SEL;
N    BOD_EN_T      BOD_EN;
N    DET_TIMER_T   DET_TIMER;
N} BOD_T;
N
N/*------------------------------- TALARM Controller -------------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  LVL:4;
X    volatile uint32_t  LVL:4;
N    __I  uint32_t  RESERVE:28;
X    volatile const  uint32_t  RESERVE:28;
N} TALARM_SEL_T;
N
Ntypedef struct
N{
N    __IO uint32_t  EN:1;
X    volatile uint32_t  EN:1;
N    __I  uint32_t  TEPALARM:1;
X    volatile const  uint32_t  TEPALARM:1;
N    __IO uint32_t  IE:1;
X    volatile uint32_t  IE:1;
N    __IO uint32_t  INT:1;
X    volatile uint32_t  INT:1;
N    __I  uint32_t  RESERVE:28;
X    volatile const  uint32_t  RESERVE:28;
N} TALARM_EN_T;
N
Ntypedef struct
N{
N    TALARM_SEL_T  TALARM_SEL;
N    TALARM_EN_T   TALARM_EN;
N} TALARM_T;
N
N
N/*----------------------------- BIQ Controller -------------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  EN:1;       //0
X    volatile uint32_t  EN:1;       
N    __IO uint32_t  SELPWM:1;   //1
X    volatile uint32_t  SELPWM:1;   
N    __IO uint32_t  PRGCOEF:1;  //2
X    volatile uint32_t  PRGCOEF:1;  
N    __IO uint32_t  RSTn:1;     //3
X    volatile uint32_t  RSTn:1;     
N    __IO uint32_t  UPSR:3;     //4:6
X    volatile uint32_t  UPSR:3;     
N    __I  uint32_t  RESERVE2:9; //7:15
X    volatile const  uint32_t  RESERVE2:9; 
N    __IO uint32_t  SR_DIV:13;  //16:28
X    volatile uint32_t  SR_DIV:13;  
N    __I  uint32_t  RESERVE3:2; //29:30
X    volatile const  uint32_t  RESERVE3:2; 
N	__IO uint32_t  AGC_BIQ_SELn:1; // 31
X	volatile uint32_t  AGC_BIQ_SELn:1; 
N} BIQ_CTRL_T;
N
Ntypedef struct
N{
N    __IO uint32_t  BIST:1;
X    volatile uint32_t  BIST:1;
N    __I uint32_t   FAIL:1;
X    volatile const uint32_t   FAIL:1;
N    __I uint32_t   DONE:1;
X    volatile const uint32_t   DONE:1;
N    __I  uint32_t  RESERVE1:28;
X    volatile const  uint32_t  RESERVE1:28;
N} BIQ_TST_T;
N
Ntypedef struct
N{
N    __IO uint32_t  BIQ_COEFF[16]; //BIQ_BA + 0x00
X    volatile uint32_t  BIQ_COEFF[16]; 
N    BIQ_CTRL_T     BIQ_CTRL;      //BIQ_BA + 0x40
N    BIQ_TST_T      BIQ_TEST;      //BIQ_BA + 0x44
N} BIQ_T;
N
N/*------------------------------- ALC (Automatic Level Control ----------------*/
Ntypedef struct
N{
N    __IO uint32_t  NGTH:3;        // 2:0
X    volatile uint32_t  NGTH:3;        
N    __IO uint32_t  NGEN:1;        // 3
X    volatile uint32_t  NGEN:1;        
N    __IO uint32_t  ALCATK:4;      // 7:4
X    volatile uint32_t  ALCATK:4;      
N    __IO uint32_t  ALCDCY:4;      // 11:8
X    volatile uint32_t  ALCDCY:4;      
N    __IO uint32_t  ALCMODE:1;     // 12
X    volatile uint32_t  ALCMODE:1;     
N    __IO uint32_t  ALCLVL:4;      // 16:13
X    volatile uint32_t  ALCLVL:4;      
N    __IO uint32_t  ALCHLD:4;      // 20:17
X    volatile uint32_t  ALCHLD:4;      
N    __IO uint32_t  ALCZC:1;       // 21
X    volatile uint32_t  ALCZC:1;       
N    __IO uint32_t  ALCMIN:3;      // 24:22
X    volatile uint32_t  ALCMIN:3;      
N    __IO uint32_t  ALCMAX:3;      // 27:25
X    volatile uint32_t  ALCMAX:3;      
N    __IO uint32_t  ALCSEL:1;      // 28
X    volatile uint32_t  ALCSEL:1;      
N    __IO uint32_t  ALCNGSEL:1;    // 29
X    volatile uint32_t  ALCNGSEL:1;    
N    __IO uint32_t  ALCPKSEL:1;    // 30
X    volatile uint32_t  ALCPKSEL:1;    
N    __IO uint32_t  ALCPKLIM:1;    // 31
X    volatile uint32_t  ALCPKLIM:1;    
N} ALC_REG_T;
N
Ntypedef struct
N{
N    __I uint32_t   FAST_DEC:1;    // 0
X    volatile const uint32_t   FAST_DEC:1;    
N    __I uint32_t   NOISE:1;       // 1
X    volatile const uint32_t   NOISE:1;       
N    __I uint32_t   P2P:9;         // 11:3
X    volatile const uint32_t   P2P:9;         
N    __I uint32_t   PEAK:9;        //
X    volatile const uint32_t   PEAK:9;        
N    __I uint32_t   RESERVE:12;    //
X    volatile const uint32_t   RESERVE:12;    
N
N} ALC_STATUS_T;
Ntypedef struct
N{
N    __IO uint32_t   INT:1;    // 0
X    volatile uint32_t   INT:1;    
N    __I uint32_t   RESERVE:31; //
X    volatile const uint32_t   RESERVE:31; 
N
N} ALC_INT_T;
Ntypedef struct
N{
N    __IO uint32_t   EN;    // 0
X    volatile uint32_t   EN;    
N    __I uint32_t   RESERVE:31; //
X    volatile const uint32_t   RESERVE:31; 
N
N} ALC_INTEN_T;
N
Ntypedef struct
N{
N    ALC_REG_T      ALC_CTRL;       //ALC_BA + 0x0
N    ALC_STATUS_T   ALC_STATUS;    //ALC_BA + 0x4
N    ALC_INT_T      ALC_INT;       //ALC_BA + 0x8
N    ALC_INTEN_T    ALC_INTEN;     //ALC_BA + 0xC
N} ALC_T;
N
N/////*----------------------------- CRC Controller -------------------------------*/
N////typedef struct
N////{
N////    __IO uint32_t  LEN:9;
N////    __I  uint32_t  RESERVE1:7;
N////    __IO uint32_t  LSB:1;
N////    __I  uint32_t  RESERVE2:15;
N////} CRC_EN_T;
N////
N////typedef struct
N////{
N////    CRC_EN_T       CRC_EN;
N////    __IO uint32_t  CRC_IN;
N////    __I  uint32_t  CRC_OUT;
N////} CRC_T;
N////
N/*----------------------------- SBRAM Controller -------------------------------*/
Ntypedef struct
N{
N    __IO uint32_t	D[64];
X    volatile uint32_t	D[64];
N} SBRAM_T;
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/** @addtogroup ISD91XX_MemoryMap ISD91XX Memory Mapping
N    @{
N*/
N/* Peripheral and SRAM base address */
N#define FLASH_BA          ((     uint32_t)0x00000000)
N#define SRAM_BA           ((     uint32_t)0x20000000)
N#define AHB_BA            ((     uint32_t)0x50000000)
N#define APB1_BA           ((     uint32_t)0x40000000)
N
N/* Peripheral memory map */
N
N#define WDT_BA       	   (APB1_BA      + 0x04000)
N#define RTC_BA             (APB1_BA      + 0x08000)
N#define TIMER0_BA          (APB1_BA      + 0x10000)
N#define TIMER1_BA          (APB1_BA      + 0x10020)
N#define I2C0_BA            (APB1_BA      + 0x20000)
N#define SPI0_BA            (APB1_BA      + 0x30000)
N#define PWMA_BA            (APB1_BA      + 0x40000)
N#define PWMB_BA            (APB1_BA      + 0x40080)
N#define UART0_BA           (APB1_BA      + 0x50000)
N#define DPWM_BA            (APB1_BA      + 0x70000)
N#define ANA_BA             (APB1_BA      + 0x80000)
N#define BOD_BA             (APB1_BA      + 0x84000)
N#define TALARM_BA          (APB1_BA      + 0x84008)
N#define I2S_BA             (APB1_BA      + 0xA0000)
N#define BIQ_BA             (APB1_BA      + 0xB0000)
N#define ALC_BA             (APB1_BA      + 0xB0048)
N#define ACMP_BA            (APB1_BA      + 0xD0000)
N#define ADC_BA             (APB1_BA      + 0xE0000)
N#define SBRAM_BA           (APB1_BA      + 0xF0000)
N
N#define GCR_BA             (AHB_BA       + 0x00000)
N#define CLK_BA             (AHB_BA       + 0x00200)
N#define INT_BA             (AHB_BA       + 0x00300)
N#define GPIO_MAP_BA        (AHB_BA       + 0x00400)
N#define GPIO_BA            (AHB_BA       + 0x04000)
N#define GPIOA_BA           (GPIO_BA               )
N#define GPIOB_BA           (GPIO_BA      + 0x00040)
N#define GPIO_DBNCECON_BA   (GPIO_BA      + 0x00180)
N
N#define PDMA_BA            (AHB_BA       + 0x08000)
N#define PDMA0_BA           (AHB_BA       + 0x08000)
N#define PDMA1_BA           (AHB_BA       + 0x08100)
N#define PDMA2_BA           (AHB_BA       + 0x08200)
N#define PDMA3_BA           (AHB_BA       + 0x08300)
N#define PDMACRC_BA	       (AHB_BA       + 0x08E00)
N#define PDMA_GCR_BA        (AHB_BA       + 0x08F00)
N
N#define FMC_BA             (AHB_BA       + 0x0C000)
N/*@}*/ /* end of group ISD91XX_MemoryMap */
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N/** @addtogroup ISD91XX_PeripheralDecl ISD91XX Peripheral Declaration
N    @{
N*/
N#define GPIOA               ((GPIO_T *) GPIOA_BA)
N#define GPIOB               ((GPIO_T *) GPIOB_BA)
N#define GPIO_DBNCECON       ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BA)
N
N#define UART0               ((UART_T *) UART0_BA)
N#define DPWM                ((DPWM_T *) DPWM_BA)
N
N#define TIMER0              ((TIMER_T *) TIMER0_BA)
N#define TIMER1              ((TIMER_T *) TIMER1_BA)
N
N#define WDT                 ((WDT_T *) WDT_BA)
N
N#define SPI0                ((SPI_T *) SPI0_BA)
N
N#define I2C0                ((I2C_T *) I2C0_BA)
N
N#define I2S                 ((I2S_T *) I2S_BA)
N
N#define RTC                 ((RTC_T *) RTC_BA)
N
N#define SDADC               ((SDADC_T*) ADC_BA)
N
N#define ACMP                ((ACMP_T *) ACMP_BA)
N#define ANA					((ANA_T *) ANA_BA)
N#define BOD                 ((BOD_T *) BOD_BA)
N#define TALARM              ((TALARM_T *) TALARM_BA)
N
N//#define CRC                 ((CRC_T *) CRC_BA)
N#define BIQ                 ((BIQ_T *) BIQ_BA)
N#define ALC                 ((ALC_T *) ALC_BA)
N#define SBRAM				((SBRAM_T *) SBRAM_BA)
N
N#define SYSCLK              ((SYSCLK_T *)CLK_BA)
N#define SYS                 ((GCR_T *) GCR_BA)
N
N#define SYSINT              ((GCR_INT_T *) INT_BA)
N
N#define FMC                 ((FMC_T *) FMC_BA)
N
N#define PDMA0               ((PDMA_T *) PDMA0_BA)
N#define PDMA1               ((PDMA_T *) PDMA1_BA)
N#define PDMA2               ((PDMA_T *) PDMA2_BA)
N#define PDMA3               ((PDMA_T *) PDMA3_BA)
N#define PDMACRC             ((PDMACRC_T *)  PDMACRC_BA)
N//#define PDMA_GCR            ((PDMA_GCR_GCR_T *) PDMA_GCR_BA)
N#define PDMA_GCR            ((PDMA_GCR_T *) PDMA_GCR_BA)
N#define PDMA                ((PDMA_PERIPH_T *) PDMA_BA)
N
N#define PWMA                ((PWM_T *) PWMA_BA)
N#define PWMB                ((PWM_T *) PWMB_BA)
N
N/*@}*/ /* end of group ISD91XX_PeripheralDecl */
N
N/*@}*/ /* end of group ISD91XX_Definitions */
N
N
N/******************************************************************************/
N/*                         Useful Macros                                      */
N/******************************************************************************/
N
N/*  Send the Protected Register Unlock Sequence                               */
N#define UNLOCKREG(x)        SYS->REGLOCK=0x59;SYS->REGLOCK=0x16;SYS->REGLOCK=0x88
N
N/*  Lock Protected Registers                                                  */
N#define LOCKREG(x)          SYS->REGLOCK=0x00;
N
N/*  Copy a Register                                                           */
N#define REGCOPY(dest, src)  *((uint32_t *)&(dest)) = *((uint32_t *)&(src))
N/*  Clear a Register                                                          */
N#define CLEAR(dest) 		*((uint32_t *)&(dest)) = 0
N
N//=============================================================================
Ntypedef volatile unsigned char  vu8;
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
N/******************************************************************************/
N/*  Macros to access 8/16/32 bit memory locations                             */
N/******************************************************************************/
N#define M8(adr)  (*((vu8  *) (adr)))
N#define M16(adr) (*((vu16 *) (adr)))
N#define M32(adr) (*((vu32 *) (adr)))
N#define outpw(port,value)	*((vu32 *)(port))=value
N#define inpw(port)			(*((vu32 *)(port)))
N#define outpb(port,value)	*((vu8 *)(port))=value
N#define inpb(port)			(*((vu8 *)(port)))
N#define outps(port,value)	*((vu16 *)(port))=value
N#define inps(port)			(*((vu16 *)(port)))
N/******************************************************************************/
N
N#define E_SUCCESS 	0
N#define NULL         0
N
N#ifndef TRUE
N#define TRUE	   	1
N#endif
N#ifndef FALSE
N#define FALSE   	0
N#endif
N
N#define ENABLE     1
N#define DISABLE    0
N
N// Define one bit mask
N#define BIT0	0x00000001
N#define BIT1	0x00000002
N#define BIT2	0x00000004
N#define BIT3	0x00000008
N#define BIT4	0x00000010
N#define BIT5	0x00000020
N#define BIT6	0x00000040
N#define BIT7	0x00000080
N#define BIT8	0x00000100
N#define BIT9	0x00000200
N#define BIT10	0x00000400
N#define BIT11	0x00000800
N#define BIT12	0x00001000
N#define BIT13	0x00002000
N#define BIT14	0x00004000
N#define BIT15	0x00008000
N#define BIT16	0x00010000
N#define BIT17	0x00020000
N#define BIT18	0x00040000
N#define BIT19	0x00080000
N#define BIT20	0x00100000
N#define BIT21	0x00200000
N#define BIT22	0x00400000
N#define BIT23	0x00800000
N#define BIT24	0x01000000
N#define BIT25	0x02000000
N#define BIT26	0x04000000
N#define BIT27	0x08000000
N#define BIT28	0x10000000
N#define BIT29	0x20000000
N#define BIT30	0x40000000
N#define BIT31	0x80000000
N
N#ifdef __cplusplus
S}
N#endif
N#endif  // __ISD93XX_H__
L 10 "..\..\..\Include\Driver\DrvI2S.h" 2
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Version number								                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DRVI2S_MAJOR_NUM	1
N#define DRVI2S_MINOR_NUM	00
N#define DRVI2S_BUILD_NUM	1
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Version define with SysInfra				                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DRVI2S_VERSION_NUM     _SYSINFRA_VERSION(DRVI2S_MAJOR_NUM, DRVI2S_MINOR_NUM, DRVI2S_BUILD_NUM)
N							   
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Error Code									                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N// E_DRVI2S_ERR_ARGUMENT  		Wrong Argument
N#define E_DRVI2S_ERR_ARGUMENT   _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVI2S, 1)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define parameter                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DRVI2S_DATABIT_8			0x00
N#define DRVI2S_DATABIT_16			0x01
N#define DRVI2S_DATABIT_24			0x02
N#define DRVI2S_DATABIT_32			0x03
N
N/* Audio Format	*/
N#define DRVI2S_MONO					0x01
N#define DRVI2S_STEREO				0x00
N
N/* I2S Data Format */
N#define DRVI2S_FORMAT_MSB 			0x01
N#define DRVI2S_FORMAT_I2S			0x00
N
N/* I2S Operation mode */
N#define DRVI2S_MODE_SLAVE			0x01
N#define DRVI2S_MODE_MASTER			0x00
N
N/* I2S FIFO Threshold */
N#define DRVI2S_FIFO_LEVEL_WORD_0	0x00
N#define DRVI2S_FIFO_LEVEL_WORD_1	0x01
N#define DRVI2S_FIFO_LEVEL_WORD_2	0x02
N#define DRVI2S_FIFO_LEVEL_WORD_3	0x03
N#define DRVI2S_FIFO_LEVEL_WORD_4	0x04
N#define DRVI2S_FIFO_LEVEL_WORD_5	0x05
N#define DRVI2S_FIFO_LEVEL_WORD_6	0x06
N#define DRVI2S_FIFO_LEVEL_WORD_7	0x07
N#define DRVI2S_FIFO_LEVEL_WORD_8	0x08
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2S Clcok Source Selector						                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DRVI2S_INTERNAL_10K	  0
N#define DRVI2S_EXT_32K        1
N#define DRVI2S_HCLK           2
N#define DRVI2S_INTERNAL_48M   3
N
N
N/* Write data to Tx FIFO */
N#define _DRVI2S_WRITE_TX_FIFO(u32Data)  I2S->TXFIFO = u32Data
N
N/* Write data from Rx FIFO */
N#define _DRVI2S_READ_RX_FIFO()   	 	I2S->RXFIFO
N
N/* Read word data number in Tx FIFO */
N#define _DRVI2S_READ_TX_FIFO_LEVEL()  	I2S->STATUS.TX_LEVEL
N
N/* Read word data number in Rx FIFO */
N#define _DRVI2S_READ_RX_FIFO_LEVEL()   	I2S->STATUS.RX_LEVEL
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* I2S Interrupt Flag                                                                              		   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2S_I2SRXINT				0x00000002
N#define I2S_I2STXINT				0x00000004
N
N#define I2S_RXUDF					0x00000100
N#define I2S_RXOVF					0x00000200
N
N#define I2S_TXUDF					0x00010000
N#define I2S_TXOVF					0x00020000
N#define I2S_RZCF					0x00400000
N#define I2S_LZCF					0x00800000
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2S Data Structure 								                                          	           */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N	uint32_t	u32SampleRate;
N	uint8_t	  	u8WordWidth;
N	uint8_t	  	u8AudioFormat;
N	uint8_t	  	u8DataFormat;
N	uint8_t	  	u8Mode;
N	uint8_t	  	u8TxFIFOThreshold;
N	uint8_t	  	u8RxFIFOThreshold;
N
N}S_DRVI2S_DATA_T;
N
Ntypedef enum
N{
N	I2S_RX_UNDERFLOW   		=  0, 
N	I2S_RX_OVERFLOW 		=  1,
N	I2S_RX_FIFO_THRESHOLD  	=  2,
N
N	I2S_TX_UNDERFLOW   		=  8, 
N	I2S_TX_OVERFLOW 		=  9,
N	I2S_TX_FIFO_THRESHOLD   = 10,
N	I2S_TX_RIGHT_ZERO_CROSS = 11,
N	I2S_TX_LEFT_ZERO_CROSS  = 12
N} E_I2S_CALLBACK_TYPE;
N
Ntypedef enum
N{
N	I2S_LEFT_CHANNEL  =  0, 
N	I2S_RIGHT_CHANNEL =  1
N} E_I2S_CHANNEL;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2S Callback function								                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef void (*I2S_CALLBACK)(uint32_t status);
N
Ntypedef struct
N{
N    I2S_CALLBACK	RxUnderflowFn;
N    I2S_CALLBACK	RxOverflowFn;    
N    I2S_CALLBACK	RxFifoThresholdFn;
N    
N	I2S_CALLBACK	TxUnderflowFn;
N    I2S_CALLBACK	TxOverflowFn;
N    I2S_CALLBACK	TxFifoThresholdFn;    
N    I2S_CALLBACK	TxRightZeroCrossFn;
N    I2S_CALLBACK	TxLeftZeroCrossFn;
N}I2S_CALLBACK_T;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define I2S functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvI2S_ClearRxFIFO(void);
Nvoid DrvI2S_ClearTxFIFO(void);
Nvoid DrvI2S_Close(void);
Nint32_t DrvI2S_DisableInt(E_I2S_CALLBACK_TYPE Type);
Nint32_t DrvI2S_EnableInt(E_I2S_CALLBACK_TYPE Type, I2S_CALLBACK callbackfn);
Nvoid DrvI2S_EnableMCLK(int32_t i32flag);
Nvoid DrvI2S_EnableRx(int32_t i32flag);
Nvoid DrvI2S_EnableRxDMA(int32_t i32flag);
Nvoid DrvI2S_EnableTx(int32_t i32flag);
Nvoid DrvI2S_EnableTxDMA(int32_t i32flag);
Nvoid DrvI2S_EnableTxMute(int32_t i32flag);
Nint32_t DrvI2S_EnableZeroCrossDetect(E_I2S_CHANNEL channel, int32_t i32flag);
Nuint32_t DrvI2S_GetBCLK(void);
Nuint32_t DrvI2S_GetMCLK(void);
Nuint32_t DrvI2S_GetSourceClock(void);
Nuint32_t DrvI2S_GetVersion(void);
Nint32_t DrvI2S_Open(S_DRVI2S_DATA_T *sParam);
Nvoid DrvI2S_SelClockSource(uint8_t u8ClkSrcSel);
Nvoid DrvI2S_SetBCLK(uint32_t u32Bclk);
Nvoid DrvI2S_SetMCLK(uint32_t u32Mclk);
N
N#endif
N
L 8 "..\..\..\Src\Driver\DrvI2S.c" 2
N#include "DrvSYS.h"
L 1 "..\..\..\Include\Driver\DrvSYS.h" 1
N/*-----------------------------------------------------------------------------------*/
N/*                                                                                   */
N/* Copyright(c) 2013 Nuvoton Technology Corp. All rights reserved.                   */
N/*                                                                                   */
N/*-----------------------------------------------------------------------------------*/
N#ifndef DRVSYS_H
N#define DRVSYS_H
N
N/*-----------------------------------------------------------------------------------*/
N/* Include related headers                                                           */
N/*-----------------------------------------------------------------------------------*/
N#include "isd93xx.h"
N/*-----------------------------------------------------------------------------------*/
N/*  Define Version number					                     */
N/*-----------------------------------------------------------------------------------*/
N#define DRVSYS_MAJOR_NUM 1
N#define DRVSYS_MINOR_NUM 00
N#define DRVSYS_BUILD_NUM 1
N
N/*-----------------------------------------------------------------------------------*/
N/*  Version define with SysInfra				                     */
N/*-----------------------------------------------------------------------------------*/
N#define DRVSYS_VERSION_NUM      _SYSINFRA_VERSION(DRVSYS_MAJOR_NUM,DRVSYS_MINOR_NUM,DRVSYS_BUILD_NUM)  
N
N/*-----------------------------------------------------------------------------------*/
N/*  Define Error Code						                     */
N/*-----------------------------------------------------------------------------------*/
N//E_DRVSYS_ERR_UNLOCK_FAIL      Unlock key address failed
N//E_DRVSYS_ERR_LOCK_FAIL      Lock key address failed
N//E_DRVSYS_ERR_ARGUMENT       Wrong Argument
N//E_DRVSYS_ERR_IPSRC          Wrong IP clock selection
N//E_DRVSYS_ERR_IPDIV          Wrong IP divider selection
N#define E_DRVSYS_ERR_UNLOCK_FAIL    _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVSYS, 1)
N#define E_DRVSYS_ERR_LOCK_FAIL    _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVSYS, 2)
N#define E_DRVSYS_ERR_ARGUMENT       _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVSYS, 3)    
N#define E_DRVSYS_ERR_IPSRC      _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVSYS, 4)    
N#define E_DRVSYS_ERR_IPDIV      _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVSYS, 5)    
N
N#define MIN_WAIT   E_DRVFMC_ONE_WAIT
N#define wait_cfg(x) ( (x > 73728000) ? E_DRVFMC_THREE_WAIT : (x >  49152000) ? E_DRVFMC_TWO_WAIT : (x >  24576000) ? E_DRVFMC_ONE_WAIT : MIN_WAIT ) 
N#define num_wait_states(x) ( (x & E_DRVFMC_TWO_WAIT) ? 2 : (x & E_DRVFMC_ONE_WAIT) ? 1 : (x & E_DRVFMC_FOUR_WAIT) ? 4 : 3 )
N
N/*----------------------------------------------------------------------------------*/
N/*  HCLK frequency selector                                                         */
N/*----------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N    E_DRVSYS_48M = 0,
N    E_DRVSYS_32M = 1,   
N    E_DRVSYS_36M = 2,   
N    E_DRVSYS_72M = 3,   
N    E_DRVSYS_64M = 4,   
N    E_DRVSYS_96M = 5,
N    E_DRVSYS_32K = 6,
N    E_DRVSYS_10K = 7   
N}E_SYS_HCLK_SRC;
N
N/*----------------------------------------------------------------------------------*/
N/*  IP reset                                                                        */
N/*----------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N    E_SYS_TMR0_RST  = 6,
N    E_SYS_TMR1_RST  = 7,
N    E_SYS_I2C0_RST  = 8,
N    E_SYS_SPI0_RST  = 12,
N    E_SYS_DPWM_RST  = 13,
N    E_SYS_UART0_RST  = 16,
N    E_SYS_BIQ_RST  = 18,
N    E_SYS_CRC_RST  = 19,
N    E_SYS_PWM03_RST  = 20,
N    E_SYS_PWM47_RST  = 21,
N    E_SYS_ACMP_RST  = 22,
N    E_SYS_ADC_RST = 28,
N    E_SYS_I2S_RST = 29,
N    E_SYS_ANA_RST = 30,   
N    E_SYS_PDMA_RST = 32
N}E_SYS_IP_RST;
N
N/*-----------------------------------------------------------------------------------*/
N/*  SYS IP Clcok Selector                                                            */
N/*-----------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N    E_SYS_WDG_CLK   = 1,
N    E_SYS_RTC_CLK   = 5,    
N    E_SYS_TMR0_CLK  = 6,
N    E_SYS_TMR1_CLK  = 7,
N    E_SYS_I2C0_CLK  = 8,
N    E_SYS_SPI0_CLK  = 12,
N    E_SYS_DPWM_CLK  = 13,
N    E_SYS_UART0_CLK = 16,
N    E_SYS_BIQ_CLK   = 18,   
N    E_SYS_CRC_CLK   = 19,     
N    E_SYS_PWM01_CLK = 20,
N    E_SYS_PWM23_CLK = 21,
N    E_SYS_ACMP_CLK  = 22,
N    E_SYS_SBRAM_CLK = 26,  
N    E_SYS_ADC_CLK   = 28,
N    E_SYS_I2S_CLK   = 29,
N    E_SYS_ANA_CLK   = 30,
N    E_SYS_PWM45_CLK = 31,
N    E_SYS_PDMA_CLK  = 33,
N    E_SYS_ISP_CLK   = 34
N}E_SYS_IP_CLK;
N
N
N/*-----------------------------------------------------------------------------------*/
N/*  SYS IP Clcok Divider                                                             */
N/*-----------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N    E_SYS_ADC_DIV,
N    E_SYS_UART_DIV,
N    E_SYS_HCLK_DIV
N}E_SYS_IP_DIV;
N
N
N/*-----------------------------------------------------------------------------------*/
N/*  SYS IP Clcok Selector                                                            */
N/*-----------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N    E_SYS_I2S_CLKSRC,
N    E_SYS_PWM45_CLKSRC,
N    E_SYS_PWM23_CLKSRC,
N    E_SYS_PWM01_CLKSRC,
N    E_SYS_TMR1_CLKSRC,
N    E_SYS_TMR0_CLKSRC,
N    E_SYS_WDG_CLKSRC, 
N    E_SYS_DPWM_CLKSRC 
N}E_SYS_IP_CLKSRC;
N
N/*--------------------------------------------------------------------------------*/
N/*  SYS Oscillator Control                                                        */
N/*--------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N    E_SYS_NONE,
N    E_SYS_XTL32K,
N    E_SYS_OSC49M,
N    E_SYS_OSC10K
N}E_SYS_OSC_CTRL;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define GCR functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nuint32_t DrvSYS_ReadProductID(void);
Nint32_t DrvSYS_UnlockKeyAddr(void);
Nint32_t DrvSYS_LockKeyAddr(void);
Nuint32_t DrvSYS_GetRstSrc(void);
Nuint32_t DrvSYS_ClearRstSrc(uint32_t u32Src);
Nvoid DrvSYS_ResetIP(E_SYS_IP_RST eIpRst);
Nvoid DrvSYS_ResetCPU(void);
Nvoid DrvSYS_ResetChip(void);
Nvoid DrvSYS_SetRCAdjValue(uint32_t u32Adj);
Nvoid DrvSYS_SetIPClock(E_SYS_IP_CLK eIpClk, int32_t i32Enable);
Nint32_t DrvSYS_SetHCLK(E_SYS_HCLK_SRC eHClkSrc, uint8_t u8HclkDiv);
Nint32_t DrvSYS_SetSysTickSource(uint8_t u8ClkSrcSel);
Nint32_t DrvSYS_SetIPClockSource(E_SYS_IP_CLKSRC eIpClkSrc, uint8_t u8ClkSrcSel);
Nint32_t DrvSYS_SetClockDivider(E_SYS_IP_DIV eIpDiv , int32_t i32value);
Nint32_t DrvSYS_SetOscCtrl(E_SYS_OSC_CTRL eOscCtrl, int32_t i32Enable);
Nuint32_t DrvSYS_GetEXTClock(void);
Nuint32_t DrvSYS_GetHCLK(void);
Nuint32_t DrvSYS_GetHCLKHz(void);
Nuint32_t DrvSYS_GetVersion(void);
N
N#endif
N
L 9 "..\..\..\Src\Driver\DrvI2S.c" 2
N
Nstatic I2S_CALLBACK_T I2SHandler = {0};
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function:     <I2S_IRQHandler>                                                                          */
N/*                                                                                                         */
N/* Parameter:                                                                                              */
N/*               None                                                                                      */
N/* Returns:                                                                                                */
N/*               None                                                                                      */
N/*                                                                                                         */
N/* Description:                                                                                            */
N/*               ISR to handle I2S interrupt event           		                                       */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid I2S_IRQHandler(void)
N{
N    uint32_t u32Reg;
N
N	u32Reg = inpw(&(I2S->STATUS));
X	u32Reg = (*((vu32 *)(&(((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->STATUS))));
N
N	if (u32Reg & I2S_I2STXINT)
X	if (u32Reg & 0x00000004)
N	{
N		/* Tx underflow */
N		if ((u32Reg & I2S_TXUDF) && (I2S->IE.TXUDFIE == 1))
X		if ((u32Reg & 0x00010000) && (((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->IE.TXUDFIE == 1))
N		{
N			if (I2SHandler.TxUnderflowFn)
N				I2SHandler.TxUnderflowFn(u32Reg);
N
N			outpw(&(I2S->STATUS), I2S_TXUDF);
X			*((vu32 *)(&(((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->STATUS)))=0x00010000;
N		}
N		/* Tx overflow */
N		else if ((u32Reg & I2S_TXOVF) && (I2S->IE.TXOVFIE == 1))
X		else if ((u32Reg & 0x00020000) && (((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->IE.TXOVFIE == 1))
N		{
N			if (I2SHandler.TxOverflowFn)
N				I2SHandler.TxOverflowFn(u32Reg);
N
N			outpw(&(I2S->STATUS), I2S_TXOVF);
X			*((vu32 *)(&(((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->STATUS)))=0x00020000;
N		}
N		/* Tx right zero cross */
N		else if ((u32Reg & I2S_RZCF) && (I2S->IE.RZCIE == 1))
X		else if ((u32Reg & 0x00400000) && (((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->IE.RZCIE == 1))
N		{
N			if (I2SHandler.TxRightZeroCrossFn)
N				I2SHandler.TxRightZeroCrossFn(u32Reg);
N			outpw(&(I2S->STATUS), I2S_RZCF);
X			*((vu32 *)(&(((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->STATUS)))=0x00400000;
N		}
N		/* Tx left zero cross */
N		else if ((u32Reg & I2S_LZCF) && (I2S->IE.LZCIE == 1))
X		else if ((u32Reg & 0x00800000) && (((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->IE.LZCIE == 1))
N		{
N			if (I2SHandler.TxLeftZeroCrossFn)
N				I2SHandler.TxLeftZeroCrossFn(u32Reg);
N			outpw(&(I2S->STATUS), I2S_LZCF);
X			*((vu32 *)(&(((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->STATUS)))=0x00800000;
N		}
N		/* Tx threshold level */
N		else if (I2S->IE.TXTHIE == 1)
X		else if (((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->IE.TXTHIE == 1)
N		{
N			if (I2SHandler.TxFifoThresholdFn)
N				I2SHandler.TxFifoThresholdFn(u32Reg);
N		}
N	}
N	else if (u32Reg & I2S_I2SRXINT)
X	else if (u32Reg & 0x00000002)
N	{
N		/* Rx underflow */
N		if ((u32Reg & I2S_RXUDF) && (I2S->IE.RXUDFIE == 1))
X		if ((u32Reg & 0x00000100) && (((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->IE.RXUDFIE == 1))
N		{
N			if (I2SHandler.RxUnderflowFn)
N				I2SHandler.RxUnderflowFn(u32Reg);
N
N			outpw(&(I2S->STATUS), I2S_RXUDF);
X			*((vu32 *)(&(((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->STATUS)))=0x00000100;
N		}
N		/* Rx overflow */
N		else if ((u32Reg & I2S_RXOVF) && (I2S->IE.RXOVFIE == 1))
X		else if ((u32Reg & 0x00000200) && (((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->IE.RXOVFIE == 1))
N		{
N			if (I2SHandler.RxOverflowFn)
N				I2SHandler.RxOverflowFn(u32Reg);
N
N			outpw(&(I2S->STATUS), I2S_RXOVF);
X			*((vu32 *)(&(((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->STATUS)))=0x00000200;
N		}
N		/* Rx threshold level */
N		else if (I2S->IE.RXTHIE == 1)
X		else if (((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->IE.RXTHIE == 1)
N		{
N			if (I2SHandler.RxFifoThresholdFn)
N				I2SHandler.RxFifoThresholdFn(u32Reg);
N		}
N	}
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_Open					                                             		    	   */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*				 S_DRVI2S_DATA_T *sParam - [in]	Data structure to configure 					    	   */
N/*               u32SampleRate					Sample rate   					       				   	   */
N/*               u8WordWidth				    Data length - DRVI2S_DATABIT_8  :  8-bit Data   	       */
N/*               							                  DRVI2S_DATABIT_16 : 16-bit Data              */
N/*               							                  DRVI2S_DATABIT_24 : 24-bit Data              */
N/*               							                  DRVI2S_DATABIT_32 : 32-bit Data              */
N/*               u8AudioFormat					Audio format- DRVI2S_MONO: Mono / DRVI2S_STEREO: Stereo    */
N/*               u8DataFormat					Data format - DRVI2S_FORMAT_I2S : I2S format     	       */
N/*               							                  DRVI2S_FORMAT_MSB : MSB justified format     */
N/*               u8Mode				            I2S operation mode - DRVI2S_MODE_MASTER: master mode	   */
N/*                                                                   DRVI2S_MODE_SLAVE : slave mode        */
N/*               u8TxFIFOThreshold			    Tx FIFO Threshold Level - DRVI2S_FIFO_LEVEL_WORD_0 : 0 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_1 : 1 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_2 : 2 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_3 : 3 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_4 : 4 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_5 : 5 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_6 : 6 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_7 : 7 Word*/
N/*               u8TxFIFOThreshold			    Rx FIFO Threshold Level - DRVI2S_FIFO_LEVEL_WORD_1 : 1 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_2 : 2 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_3 : 3 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_4 : 4 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_5 : 5 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_6 : 6 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_7 : 7 Word*/
N/*               							                              DRVI2S_FIFO_LEVEL_WORD_8 : 8 Word*/
N/*               							                                                               */
N/* Returns:                                                                                                */
N/*               0		Success											                           		   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               This function is used to configure the I2S mode/format/FIFO threshold function/BCLK       */
N/*---------------------------------------------------------------------------------------------------------*/
Nint32_t DrvI2S_Open(S_DRVI2S_DATA_T *sParam)
N{
N	uint8_t u8Divider;
N	uint32_t u32BitRate, u32SrcClk;
N
N 	SYS->IPRSTC2.I2S_RST = 1;//(0x5000_0000 + 3 << 2)[29]= 0x5000_000C[29]
X 	((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2.I2S_RST = 1;
N	SYS->IPRSTC2.I2S_RST = 0;
X	((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2.I2S_RST = 0;
N
N	SYSCLK->APBCLK.I2S_EN = 1;
X	((SYSCLK_T *)((( uint32_t)0x50000000) + 0x00200))->APBCLK.I2S_EN = 1;
N
N	I2S->CON.WORDWIDTH 	= sParam->u8WordWidth;//(0x400A_0000 + 0 << 2)[5:4]= 0x400A_0000[5:4]
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.WORDWIDTH 	= sParam->u8WordWidth;
N	I2S->CON.MONO 		= sParam->u8AudioFormat;// 0x400A_0000[6]
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.MONO 		= sParam->u8AudioFormat;
N	I2S->CON.FORMAT 	= sParam->u8DataFormat;// 0x400A_0000[7]
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.FORMAT 	= sParam->u8DataFormat;
N	I2S->CON.SLAVE 		= sParam->u8Mode;// 0x400A_0000[8]
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.SLAVE 		= sParam->u8Mode;
N	I2S->CON.TXTH 		= sParam->u8TxFIFOThreshold;// 0x400A_0000[11:9]
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.TXTH 		= sParam->u8TxFIFOThreshold;
N	I2S->CON.RXTH 		= sParam->u8RxFIFOThreshold - 1;// 0x400A_0000[14:12]
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.RXTH 		= sParam->u8RxFIFOThreshold - 1;
N
N	u32SrcClk = DrvI2S_GetSourceClock();
N
N	u32BitRate = sParam->u32SampleRate * (sParam->u8WordWidth + 1) * 16;
N
N	u8Divider = ((u32SrcClk/u32BitRate) >> 1) - 1;
N
N	I2S->CLKDIV.BCLK_DIV = u8Divider;
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CLKDIV.BCLK_DIV = u8Divider;
N
N	I2S->CON.I2SEN = 1;
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.I2SEN = 1;
N
N	return E_SUCCESS;
X	return 0;
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_Close				                                                   				   */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               None	       		                               										   */
N/* Returns:                                                                                                */
N/*               None											                    		       		   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Disable I2S function and I2S clock								          				   */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvI2S_Close(void)
N{
N	I2S->CON.I2SEN = 0;
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.I2SEN = 0;
N	SYS->IPRSTC2.I2S_RST = 1;
X	((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2.I2S_RST = 1;
N	SYS->IPRSTC2.I2S_RST = 0;
X	((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2.I2S_RST = 0;
N	SYSCLK->APBCLK.I2S_EN = 0;
X	((SYSCLK_T *)((( uint32_t)0x50000000) + 0x00200))->APBCLK.I2S_EN = 0;
N}
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_EnableInt		                                                                       */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*           Type 		 - [in] 	I2S_RX_UNDERFLOW / I2S_RX_OVERFLOW / I2S_RX_FIFO_THRESHOLD        	   */
N/*         			     			I2S_TX_UNDERFLOW / I2S_TX_OVERFLOW / I2S_TX_FIFO_THRESHOLD     		   */
N/*              	     			I2S_TX_RIGHT_ZERO_CROSS / I2S_TX_LEFT_ZERO_CROSS	               	   */
N/*           callbackfn  - [in]		The call back function for specified I2S function		   			   */
N/*              											                                        	   */
N/* Returns:                                                                                                */
N/*           0		Success																		   		   */
N/*          <0      Wrong Argument					                  		   						   	   */
N/*               			                                                                          	   */
N/* Description:                                                                                            */
N/*           This function is used to enable the I2S relative interrupt and install callback function      */
N/*---------------------------------------------------------------------------------------------------------*/
Nint32_t DrvI2S_EnableInt(E_I2S_CALLBACK_TYPE Type, I2S_CALLBACK callbackfn)
N{
N	switch (Type)
N    {
N        case I2S_RX_UNDERFLOW:
N        {
N           	I2SHandler.RxUnderflowFn = callbackfn;
N        	break;
N        }
N        case I2S_RX_OVERFLOW:
N        {
N           	I2SHandler.RxOverflowFn = callbackfn;
N        	break;
N        }
N        case I2S_RX_FIFO_THRESHOLD:
N        {
N           	I2SHandler.RxFifoThresholdFn = callbackfn;
N        	break;
N        }
N        case I2S_TX_UNDERFLOW:
N        {
N           	I2SHandler.TxUnderflowFn = callbackfn;
N        	break;
N        }
N        case I2S_TX_OVERFLOW:
N        {
N           	I2SHandler.TxOverflowFn = callbackfn;
N        	break;
N        }
N        case I2S_TX_FIFO_THRESHOLD:
N        {
N           	I2SHandler.TxFifoThresholdFn = callbackfn;
N        	break;
N        }
N        case I2S_TX_RIGHT_ZERO_CROSS:
N        {
N           	I2SHandler.TxRightZeroCrossFn = callbackfn;
N        	break;
N        }
N        case I2S_TX_LEFT_ZERO_CROSS:
N        {
N           	I2SHandler.TxLeftZeroCrossFn = callbackfn;
N        	break;
N        }
N		default:
N			return E_DRVI2S_ERR_ARGUMENT;
X			return (((1) ? 0xFFFF0000 : 0x00000000) | ((((MODULE_ID_DRVI2S) & 0xFF) | ((1) ? 0x100 : 0x00)) << 7) | ((1) & 0x7F));
N	}
N
N	outpw(&(I2S->IE), inpw(&(I2S->IE)) | (1<<Type));
X	*((vu32 *)(&(((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->IE)))=(*((vu32 *)(&(((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->IE)))) | (1<<Type);
N	NVIC_EnableIRQ(I2S_IRQn);
N
N	return E_SUCCESS;
X	return 0;
N}
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_DisableInt		                                                                       */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*           Type - [in] I2S_RX_UNDERFLOW / I2S_RX_OVERFLOW / I2S_RX_FIFO_THRESHOLD        				   */
N/*         			     I2S_TX_UNDERFLOW / I2S_TX_OVERFLOW / I2S_TX_FIFO_THRESHOLD        		   		   */
N/*              	     I2S_TX_RIGHT_ZERO_CROSS / I2S_TX_LEFT_ZERO_CROSS	                           	   */
N/*																										   */
N/* Returns:                                                                                                */
N/*           0		Success																		   		   */
N/*          <0      Wrong Argument					                  		   						   	   */
N/*               			                                                                          	   */
N/* Description:                                                                                            */
N/*           This function is used to disable the I2S relative interrupt and uninstall callback function   */
N/*---------------------------------------------------------------------------------------------------------*/
Nint32_t DrvI2S_DisableInt(E_I2S_CALLBACK_TYPE Type)
N{
N	outpw(&(I2S->IE), inpw(&(I2S->IE)) & ~(1<<Type));
X	*((vu32 *)(&(((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->IE)))=(*((vu32 *)(&(((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->IE)))) & ~(1<<Type);
N
N	switch(Type)
N    {
N        case I2S_RX_UNDERFLOW:
N        {
N           	I2SHandler.RxUnderflowFn = NULL;
X           	I2SHandler.RxUnderflowFn = 0;
N        	break;
N        }
N        case I2S_RX_OVERFLOW:
N        {
N           	I2SHandler.RxOverflowFn = NULL;
X           	I2SHandler.RxOverflowFn = 0;
N        	break;
N        }
N        case I2S_RX_FIFO_THRESHOLD:
N        {
N           	I2SHandler.RxFifoThresholdFn = NULL;
X           	I2SHandler.RxFifoThresholdFn = 0;
N        	break;
N        }
N        case I2S_TX_UNDERFLOW:
N        {
N           	I2SHandler.TxUnderflowFn = NULL;
X           	I2SHandler.TxUnderflowFn = 0;
N        	break;
N        }
N        case I2S_TX_OVERFLOW:
N        {
N           	I2SHandler.TxOverflowFn = NULL;
X           	I2SHandler.TxOverflowFn = 0;
N        	break;
N        }
N        case I2S_TX_FIFO_THRESHOLD:
N        {
N           	I2SHandler.TxFifoThresholdFn = NULL;
X           	I2SHandler.TxFifoThresholdFn = 0;
N        	break;
N        }
N        case I2S_TX_RIGHT_ZERO_CROSS:
N        {
N           	I2SHandler.TxRightZeroCrossFn = NULL;
X           	I2SHandler.TxRightZeroCrossFn = 0;
N        	break;
N        }
N        case I2S_TX_LEFT_ZERO_CROSS:
N        {
N           	I2SHandler.TxLeftZeroCrossFn = NULL;
X           	I2SHandler.TxLeftZeroCrossFn = 0;
N        	break;
N        }
N		default:
N			return E_DRVI2S_ERR_ARGUMENT;
X			return (((1) ? 0xFFFF0000 : 0x00000000) | ((((MODULE_ID_DRVI2S) & 0xFF) | ((1) ? 0x100 : 0x00)) << 7) | ((1) & 0x7F));
N	}
N
N	return E_SUCCESS;
X	return 0;
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_GetBCLK				                                                   			   	   */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               None															       		           	   */
N/*              																						   */
N/* Returns:                                                                                                */
N/*               I2S BCLK frequency 											                           */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Get I2S BCLK frequency										           					   */
N/*---------------------------------------------------------------------------------------------------------*/
Nuint32_t DrvI2S_GetBCLK(void)
N{
N	uint32_t u32Reg, u32SrcClk;
N
N	u32SrcClk = DrvI2S_GetSourceClock();
N
N	u32Reg = I2S->CLKDIV.BCLK_DIV;
X	u32Reg = ((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CLKDIV.BCLK_DIV;
N
N	return ((u32SrcClk >> 1) / (u32Reg + 1));
N}
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_SetBCLK				                                                   			   	   */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               u32Bclk 	- [in]		I2S bit clock ftequency (Hz)       		            	       	   */
N/*               							                                                               */
N/* Returns:                                                                                                */
N/*               None 											                    		       		   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Set bit clock divider if I2S operates in master mode. BCLK = I2S_CLK / (2x(divider+1))	   */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvI2S_SetBCLK(uint32_t u32Bclk)
N{
N	uint8_t u8Divider;
N	uint32_t u32SrcClk;
N
N	u32SrcClk = DrvI2S_GetSourceClock();
N
N	u8Divider = ((u32SrcClk/u32Bclk) >> 1) - 1;
N
N	I2S->CLKDIV.BCLK_DIV = u8Divider;
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CLKDIV.BCLK_DIV = u8Divider;
N}
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_GetMCLK				                                                   			   	   */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               None															       		           	   */
N/*              																						   */
N/* Returns:                                                                                                */
N/*               I2S MCLK frequency 											                           */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Get I2S MCLK frequency										           					   */
N/*---------------------------------------------------------------------------------------------------------*/
Nuint32_t DrvI2S_GetMCLK(void)
N{
N	uint32_t u32Reg, u32SrcClk;
N
N	u32Reg = I2S->CLKDIV.MCLK_DIV;
X	u32Reg = ((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CLKDIV.MCLK_DIV;
N
N	u32SrcClk = DrvI2S_GetSourceClock();
N
N	if (u32Reg == 0)
N		return u32SrcClk;
N	else
N		return ((u32SrcClk >> 1) / u32Reg);
N}
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_SetMCLK				                                                   			   	   */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               u32Mclk   - [in]		I2S master clock output ftequency (Hz)       		    	       */
N/*               							                                                               */
N/* Returns:                                                                                                */
N/*               None 											                    		       		   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Set master clock divider. MCLK = I2S_CLK / (2xdivider)		       						   */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvI2S_SetMCLK(uint32_t u32Mclk)
N{
N	uint8_t u8Divider;
N	uint32_t u32SrcClk;
N
N	u32SrcClk = DrvI2S_GetSourceClock();
N
N	if (u32Mclk == u32SrcClk)
N	{
N		u8Divider = 0;
N	}
N	else
N	{
N		u8Divider = (u32SrcClk/u32Mclk) >> 1;
N	}
N
N	I2S->CLKDIV.MCLK_DIV = u8Divider;
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CLKDIV.MCLK_DIV = u8Divider;
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_EnableZeroCrossDetect				                                       	   		   */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               channel 	- [in]		I2S_LEFT_CHANNEL / I2S_RIGHT_CHANNEL         					   */
N/*               i32flag 	- [out]		1:Enable / 0:Disable      				   						   */
N/*                     		                           	   												   */
N/* Returns:                                                                                                */
N/*               0		 Success																		   */
N/*              <0       Wrong Argument					                  		   						   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Enable/Disable left/right channel zero cross detect function  		                       */
N/*---------------------------------------------------------------------------------------------------------*/
Nint32_t DrvI2S_EnableZeroCrossDetect(E_I2S_CHANNEL channel, int32_t i32flag)
N{
N	if (channel == I2S_LEFT_CHANNEL)
N	{
N		I2S->CON.LCHZCEN = i32flag;
X		((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.LCHZCEN = i32flag;
N	}
N	else if (channel == I2S_RIGHT_CHANNEL)
N	{
N		I2S->CON.RCHZCEN = i32flag;
X		((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.RCHZCEN = i32flag;
N	}
N	else
N		return E_DRVI2S_ERR_ARGUMENT;
X		return (((1) ? 0xFFFF0000 : 0x00000000) | ((((MODULE_ID_DRVI2S) & 0xFF) | ((1) ? 0x100 : 0x00)) << 7) | ((1) & 0x7F));
N
N	return E_SUCCESS;
X	return 0;
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_EnableTxDMA				                                               	   		       */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               i32flag 	- [in]		1:Enable / 0:Disable   	   										   */
N/*                     		                           	   												   */
N/* Returns:                                                                                                */
N/*               None																		   			   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Enable/Disable I2S Tx DMA function. I2S requests DMA to transfer data to Tx FIFO          */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvI2S_EnableTxDMA(int32_t i32flag)
N{
N	I2S->CON.TXDMA = i32flag;
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.TXDMA = i32flag;
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_EnableRxDMA				                                               	   		       */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               i32flag 	- [in]		1:Enable / 0:Disable   	   										   */
N/*                     		                           	   												   */
N/*               									      		                           				   */
N/* Returns:                                                                                                */
N/*               None																		   			   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Enable/Disable I2S Rx DMA function. I2S requests DMA to transfer data from Rx FIFO        */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvI2S_EnableRxDMA(int32_t i32flag)
N{
N	I2S->CON.RXDMA = i32flag;
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.RXDMA = i32flag;
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_EnableTx				                                               	   		       */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               i32flag 	- [in]		1:Enable / 0:Disable   	   										   */
N/*                     		                           	   												   */
N/* Returns:                                                                                                */
N/*               None																		   			   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Enable/Disable I2S Tx function                            	               		   	       */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvI2S_EnableTx(int32_t i32flag)
N{
N	I2S->CON.TXEN = i32flag;
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.TXEN = i32flag;
N}
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_EnableRx				                                               	   		   	   */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               i32flag 	- [in]		1:Enable / 0:Disable   	   										   */
N/*                     		                           	   												   */
N/* Returns:                                                                                                */
N/*               None																		   			   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Enable/Disable I2S Rx function                            	               		   	   	   */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvI2S_EnableRx(int32_t i32flag)
N{
N	I2S->CON.RXEN = i32flag;
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.RXEN = i32flag;
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_EnableTxMute				                                               	   		   */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               i32flag 	- [in]		1:Enable / 0:Disable   	   										   */
N/*                     		                           	   												   */
N/* Returns:                                                                                                */
N/*               None																		   			   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Enable/Disable Tx Mute function                            	               		   	   */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvI2S_EnableTxMute(int32_t i32flag)
N{
N	I2S->CON.MUTE = i32flag;
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.MUTE = i32flag;
N}
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_EnableMCLK				                                               	   		  	   */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               i32flag 	- [in]		1:Enable / 0:Disable   	   										   */
N/*                     		                           	   												   */
N/* Returns:                                                                                                */
N/*               None																		   			   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Enable/Disable MCLK                            	               		   				   */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvI2S_EnableMCLK(int32_t i32flag)
N{
N	I2S->CON.MCLKEN = i32flag;
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.MCLKEN = i32flag;
N}
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_ClearTxFIFO				                                               				   */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               None	       		                               										   */
N/* Returns:                                                                                                */
N/*               None											                    		       		   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Clear Tx FIFO. Internal pointer is reset to FIFO start point	        				   */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvI2S_ClearTxFIFO(void)
N{
N	I2S->CON.CLR_TXFIFO = 1;
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.CLR_TXFIFO = 1;
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_ClearRxFIFO				                                                   			   */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               None	       		                               										   */
N/* Returns:                                                                                                */
N/*               None											                    		       		   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               Clear Rx FIFO. Internal pointer is reset to FIFO start point				       		   */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvI2S_ClearRxFIFO(void)
N{
N	I2S->CON.CLR_RXFIFO = 1;
X	((I2S_T *) ((( uint32_t)0x40000000) + 0xA0000))->CON.CLR_RXFIFO = 1;
N}
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_SelClockSource				                                       			           */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*           u8ClkSrcSel  - [in] DRVI2S_EXT_12M/DRVI2S_PLL/DRVI2S_HCLK/DRVI2S_INTERNAL_22M  			   */
N/*              											                                        	   */
N/* Returns:                                                                                                */
N/*               None											                    		               */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               This function is used to select I2S clock source                                   	   */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvI2S_SelClockSource(uint8_t u8ClkSrcSel)
N{
N	SYSCLK->CLKSEL2.I2S_S = u8ClkSrcSel;
X	((SYSCLK_T *)((( uint32_t)0x50000000) + 0x00200))->CLKSEL2.I2S_S = u8ClkSrcSel;
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_GetSourceClock				                                       			           */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*               None 																					   */
N/*              											                                        	   */
N/* Returns:                                                                                                */
N/*               I2S source clock frequency (Hz)										                   */
N/*               							                                                               */
N/* Description:                                                                                            */
N/*               This function is used to get I2S source clock frequency.                              	   */
N/*---------------------------------------------------------------------------------------------------------*/
Nuint32_t DrvI2S_GetSourceClock(void)
N{
N//	uint8_t  u8ClkSrcSel;
N	uint32_t u32Freq = 49152000;
N
N	if(SYSCLK->CLKSEL2.I2S_S == 0)     	/* internal 10KHz oscillator clock */
X	if(((SYSCLK_T *)((( uint32_t)0x50000000) + 0x00200))->CLKSEL2.I2S_S == 0)     	 
N	{
N		u32Freq = 10000;
N	}
N	else if(SYSCLK->CLKSEL2.I2S_S == 1)		/* external 32KHz crystal clock */
X	else if(((SYSCLK_T *)((( uint32_t)0x50000000) + 0x00200))->CLKSEL2.I2S_S == 1)		 
N	{
N		u32Freq = 32000;
N	}
N	else if(SYSCLK->CLKSEL2.I2S_S == 2)	/* HCLK */
X	else if(((SYSCLK_T *)((( uint32_t)0x50000000) + 0x00200))->CLKSEL2.I2S_S == 2)	 
N	{
N	 	u32Freq = DrvSYS_GetHCLK() * 1000;
N	}
N	else		/* internal 49MHz oscillator clock */
N	{
N		u32Freq = 49152000;
N	}
N	return u32Freq;
N}
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: DrvI2S_GetVersion                                                                             */
N/*                                                                                                         */
N/* Parameters:        	                                                                                   */
N/*               None	                                                         						   */
N/*                                                                                                         */
N/* Returns:                                                                                                */
N/*               The DrvI2S version number                                                                 */
N/*                                                                                                         */
N/* Description:                                                                                            */
N/*               This function is used to get the DrvI2S version number                                    */
N/*---------------------------------------------------------------------------------------------------------*/
Nuint32_t DrvI2S_GetVersion(void)
N{
N	return DRVI2S_VERSION_NUM;
X	return (((1) << 16) | ((00) << 8) | (1));
N}
N
